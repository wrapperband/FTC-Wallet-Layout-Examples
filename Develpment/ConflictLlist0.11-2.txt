~/Feathercoin$ git merge origin/0.11.2-wrapper
warning: Cannot merge binary files: src/qt/res/images/paper_wallet.png (HEAD vs. origin/0.11.2-wrapper)
warning: Cannot merge binary files: src/qt/res/images/about.png (HEAD vs. origin/0.11.2-wrapper)
warning: Cannot merge binary files: src/qt/res/icons/bitcoin.png (HEAD vs. origin/0.11.2-wrapper)
Auto-merging src/wallet/walletdb.h
Auto-merging src/wallet/walletdb.cpp

CONFLICT (content): Merge conflict in src/wallet/walletdb.cpp -DONE

-Copyright

Auto-merging src/wallet/wallet.cpp

CONFLICT (content): Merge conflict in src/wallet/wallet.cpp  -DONE

-Copyright

Auto-merging src/wallet/test/wallet_tests.cpp
Auto-merging src/wallet/stealth.h
Auto-merging src/wallet/stealth.cpp
Auto-merging src/wallet/rpcwallet.cpp

CONFLICT (content): Merge conflict in src/wallet/rpcwallet.cpp -DONE

-Copyright


Auto-merging src/wallet/rpcdump.cpp

CONFLICT (content): Merge conflict in src/wallet/rpcdump.cpp

Auto-merging src/wallet/db.h
Auto-merging src/wallet/db.cpp
Auto-merging src/wallet/crypter.h
Auto-merging src/wallet/crypter.cpp
Removing src/wallet.h
Auto-merging src/version.h

CONFLICT (content): Merge conflict in src/version.h

CONFLICT (modify/delete): src/version.cpp deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/version.cpp left in tree.

Auto-merging src/test/util_tests.cpp
Auto-merging src/test/transaction_tests.cpp

CONFLICT (content): Merge conflict in src/test/transaction_tests.cpp

<<<<<<< HEAD
    t.vout[0].nValue = 6011; // not dust
=======
    t.vout[0].nValue = 2730; // not dust
>>>>>>> origin/0.11.2-wrapper

Updated to Head0.9.6.2

Auto-merging src/test/sigopcount_tests.cpp
Auto-merging src/test/scriptnum_tests.cpp

CONFLICT (add/add): Merge conflict in src/test/scriptnum_tests.cpp


<<<<<< HEAD
    CScriptNum scriptnum2(scriptnum.getvch());
    BOOST_CHECK(verify(bignum2, scriptnum2));

    CBigNum bignum3(scriptnum2.getvch());
    CScriptNum scriptnum3(bignum2.getvch());
=======
    CScriptNum scriptnum2(scriptnum.getvch(), false);
    BOOST_CHECK(verify(bignum2, scriptnum2));

    CBigNum bignum3(scriptnum2.getvch());
    CScriptNum scriptnum3(bignum2.getvch(), false);
>>>>>>> origin/0.11.2-wrapper

Updated to Head


Auto-merging src/test/script_tests.cpp

CONFLICT (content): Merge conflict in src/test/script_tests.cpp

Updated to Head

Auto-merging src/test/script_P2SH_tests.cpp

CONFLICT (content): Merge conflict in src/test/script_P2SH_tests.cpp

<<<<<<< HEAD
    inner[0].SetDestination(key[0].GetPubKey().GetID());
    inner[1].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+2));
    inner[2].SetMultisig(1, std::vector<CKey>(keys.begin(), keys.begin()+2));
    inner[3].SetMultisig(2, std::vector<CKey>(keys.begin(), keys.begin()+3));
=======
    inner[0] = GetScriptForDestination(key[0].GetPubKey().GetID());
    inner[1] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+2));
    inner[2] = GetScriptForMultisig(1, std::vector<CPubKey>(keys.begin(), keys.begin()+2));
    inner[3] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+3));
>>>>>>> origin/0.11.2-wrapper

Updated to Head





Auto-merging src/test/rpc_wallet_tests.cpp

CONFLICT (content): Merge conflict in src/test/rpc_wallet_tests.cpp


<<<<<<< HEAD
=======
    CPubKey demoPubkey = pwalletMain->GenerateNewKey();
    CBitcoinAddress demoAddress = CBitcoinAddress(CTxDestination(demoPubkey.GetID()));
    Value retValue;
    string strAccount = "walletDemoAccount";
    string strPurpose = "receive";
    BOOST_CHECK_NO_THROW({ /*Initialize Wallet with an account */
        CWalletDB walletdb(pwalletMain->strWalletFile);
        CAccount account;
        account.vchPubKey = demoPubkey;
        pwalletMain->SetAddressBook(account.vchPubKey.GetID(), strAccount, strPurpose);
        walletdb.WriteAccount(strAccount, account);
    });

    CPubKey setaccountDemoPubkey = pwalletMain->GenerateNewKey();
    CBitcoinAddress setaccountDemoAddress = CBitcoinAddress(CTxDestination(setaccountDemoPubkey.GetID()));

    /*********************************
     * 			setaccount
     *********************************/
    BOOST_CHECK_NO_THROW(CallRPC("setaccount " + setaccountDemoAddress.ToString() + " nullaccount"));
    /* 1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ is not owned by the test wallet. */
    BOOST_CHECK_THROW(CallRPC("setaccount 1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ nullaccount"), runtime_error);
    BOOST_CHECK_THROW(CallRPC("setaccount"), runtime_error);
    /* 1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4X (33 chars) is an illegal address (should be 34 chars) */
    BOOST_CHECK_THROW(CallRPC("setaccount 1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4X nullaccount"), runtime_error);


    /*********************************
     *                  getbalance
     *********************************/
    BOOST_CHECK_NO_THROW(CallRPC("getbalance"));
    BOOST_CHECK_NO_THROW(CallRPC("getbalance " + demoAddress.ToString()));

    /*********************************
     * 			listunspent
     *********************************/
>>>>>>> origin/0.11.2-wrapper


Updated to head removed test



Auto-merging src/test/rpc_tests.cpp
Auto-merging src/test/multisig_tests.cpp

CONFLICT (modify/delete): src/test/miner_tests.cpp deleted in HEAD and modified in origin/0.11.2-wrapper. Version origin/0.11.2-wrapper of src/test/miner_tests.cpp left in tree.

Deleted miner_tests.cpp


Auto-merging src/test/main_tests.cpp

CONFLICT (content): Merge conflict in src/test/main_tests.cpp

<<<<<<< HEAD
    uint64_t nSum = 0;
    for (int nHeight = 0 ; nHeight < 204638; nHeight += 1000) {
        uint64_t nSubsidy = GetBlockValue(nHeight, 0);
        BOOST_CHECK(nSubsidy <= 200 * COIN);
        nSum += nSubsidy * 1000;
        BOOST_CHECK(MoneyRange(nSum));
    }
    for (int nHeight = 204639 ; nHeight < 23919999; nHeight += 1000) {
        uint64_t nSubsidy = GetBlockValue(nHeight, 0);
        BOOST_CHECK(nSubsidy <= 80 * COIN);
        nSum += nSubsidy * 1000;
        BOOST_CHECK(MoneyRange(nSum));
    }
    BOOST_CHECK_EQUAL(nSum, 33599996093750000ULL);
=======
    const Consensus::Params& consensusParams = Params(CBaseChainParams::MAIN).GetConsensus();
    CAmount nSum = 0;
    for (int nHeight = 0; nHeight < 14000000; nHeight += 1000) {
        CAmount nSubsidy = GetBlockSubsidy(nHeight, consensusParams);
        BOOST_CHECK(nSubsidy <= 50 * COIN);
        nSum += nSubsidy * 1000;
        BOOST_CHECK(MoneyRange(nSum));
    }
    BOOST_CHECK_EQUAL(nSum, 2099999997690000ULL);
}

bool ReturnFalse() { return false; }
bool ReturnTrue() { return true; }

BOOST_AUTO_TEST_CASE(test_combiner_all)
{
    boost::signals2::signal<bool (), CombinerAll> Test;
    BOOST_CHECK(Test());
    Test.connect(&ReturnFalse);
    BOOST_CHECK(!Test());
    Test.connect(&ReturnTrue);
    BOOST_CHECK(!Test());
    Test.disconnect(&ReturnFalse);
    BOOST_CHECK(Test());
    Test.disconnect(&ReturnTrue);
    BOOST_CHECK(Test());
>>>>>>> origin/0.11.2-wrapper


Updated to Head


Auto-merging src/test/key_tests.cpp

CONFLICT (content): Merge conflict in src/test/key_tests.cpp

<<<<<<< HEAD
    
    
    CSecret secret1C = bsecret1C.GetSecret(fCompressed);
    CKey key1C;
    key1C.SetSecret(secret1C, fCompressed);
    BOOST_CHECK(key1C.IsCompressed() == true);
    
    CSecret secret2C = bsecret2C.GetSecret(fCompressed);
    CKey key2C;
    key2C.SetSecret(secret2C, fCompressed);
=======
    CKey key1C = bsecret1C.GetKey();
    BOOST_CHECK(key1C.IsCompressed() == true);
    CKey key2C = bsecret2C.GetKey();
>>>>>>> origin/0.11.2-wrapper

Updated to Head


Removing src/test/hmac_tests.cpp
Auto-merging src/test/data/tx_valid.json

CONFLICT (content): Merge conflict in src/test/data/tx_valid.json


<<<<<<< HEAD
=======
["The following is 23b397edccd3740a74adb603c9756370fafcde9bcc4483eb271ecad09a94dd63"],
["It is of particular interest because it contains an invalidly-encoded signature which OpenSSL accepts"],
["See http://r6.ca/blog/20111119T211504Z.html"],
["It is also the first OP_CHECKMULTISIG transaction in standard form"],
[[["60a20bd93aa49ab4b28d514ec10b06e1829ce6818ec06cd3aabd013ebcdc4bb1", 0, "1 0x41 0x04cc71eb30d653c0c3163990c47b976f3fb3f37cccdcbedb169a1dfef58bbfbfaff7d8a473e7e2e6d317b87bafe8bde97e3cf8f065dec022b51d11fcdd0d348ac4 0x41 0x0461cbdcc5409fb4b4d42b51d33381354d80e550078cb532a34bfa2fcfdeb7d76519aecc62770f5b0e4ef8551946d8a540911abe3e7854a26f39f58b25c15342af 2 OP_CHECKMULTISIG"]],
"0100000001b14bdcbc3e01bdaad36cc08e81e69c82e1060bc14e518db2b49aa43ad90ba26000000000490047304402203f16c6f40162ab686621ef3000b04e75418a0c0cb2d8aebeac894ae360ac1e780220ddc15ecdfc3507ac48e1681a33eb60996631bf6bf5bc0a0682c4db743ce7ca2b01ffffffff0140420f00000000001976a914660d4ef3a743e3e696ad990364e555c271ad504b88ac00000000", "P2SH"],

["The following is a tweaked form of 23b397edccd3740a74adb603c9756370fafcde9bcc4483eb271ecad09a94dd63"],
["It is an OP_CHECKMULTISIG with an arbitrary extra byte stuffed into the signature at pos length - 2"],
["The dummy byte is fine however, so the NULLDUMMY flag should be happy"],
[[["60a20bd93aa49ab4b28d514ec10b06e1829ce6818ec06cd3aabd013ebcdc4bb1", 0, "1 0x41 0x04cc71eb30d653c0c3163990c47b976f3fb3f37cccdcbedb169a1dfef58bbfbfaff7d8a473e7e2e6d317b87bafe8bde97e3cf8f065dec022b51d11fcdd0d348ac4 0x41 0x0461cbdcc5409fb4b4d42b51d33381354d80e550078cb532a34bfa2fcfdeb7d76519aecc62770f5b0e4ef8551946d8a540911abe3e7854a26f39f58b25c15342af 2 OP_CHECKMULTISIG"]],
"0100000001b14bdcbc3e01bdaad36cc08e81e69c82e1060bc14e518db2b49aa43ad90ba260000000004a0048304402203f16c6f40162ab686621ef3000b04e75418a0c0cb2d8aebeac894ae360ac1e780220ddc15ecdfc3507ac48e1681a33eb60996631bf6bf5bc0a0682c4db743ce7ca2bab01ffffffff0140420f00000000001976a914660d4ef3a743e3e696ad990364e555c271ad504b88ac00000000", "P2SH,NULLDUMMY"],

["The following is a tweaked form of 23b397edccd3740a74adb603c9756370fafcde9bcc4483eb271ecad09a94dd63"],
["It is an OP_CHECKMULTISIG with the dummy value set to something other than an empty string"],
[[["60a20bd93aa49ab4b28d514ec10b06e1829ce6818ec06cd3aabd013ebcdc4bb1", 0, "1 0x41 0x04cc71eb30d653c0c3163990c47b976f3fb3f37cccdcbedb169a1dfef58bbfbfaff7d8a473e7e2e6d317b87bafe8bde97e3cf8f065dec022b51d11fcdd0d348ac4 0x41 0x0461cbdcc5409fb4b4d42b51d33381354d80e550078cb532a34bfa2fcfdeb7d76519aecc62770f5b0e4ef8551946d8a540911abe3e7854a26f39f58b25c15342af 2 OP_CHECKMULTISIG"]],
"0100000001b14bdcbc3e01bdaad36cc08e81e69c82e1060bc14e518db2b49aa43ad90ba260000000004a01ff47304402203f16c6f40162ab686621ef3000b04e75418a0c0cb2d8aebeac894ae360ac1e780220ddc15ecdfc3507ac48e1681a33eb60996631bf6bf5bc0a0682c4db743ce7ca2b01ffffffff0140420f00000000001976a914660d4ef3a743e3e696ad990364e555c271ad504b88ac00000000", "P2SH"],

["As above, but using a OP_1"],
[[["60a20bd93aa49ab4b28d514ec10b06e1829ce6818ec06cd3aabd013ebcdc4bb1", 0, "1 0x41 0x04cc71eb30d653c0c3163990c47b976f3fb3f37cccdcbedb169a1dfef58bbfbfaff7d8a473e7e2e6d317b87bafe8bde97e3cf8f065dec022b51d11fcdd0d348ac4 0x41 0x0461cbdcc5409fb4b4d42b51d33381354d80e550078cb532a34bfa2fcfdeb7d76519aecc62770f5b0e4ef8551946d8a540911abe3e7854a26f39f58b25c15342af 2 OP_CHECKMULTISIG"]],
"0100000001b14bdcbc3e01bdaad36cc08e81e69c82e1060bc14e518db2b49aa43ad90ba26000000000495147304402203f16c6f40162ab686621ef3000b04e75418a0c0cb2d8aebeac894ae360ac1e780220ddc15ecdfc3507ac48e1681a33eb60996631bf6bf5bc0a0682c4db743ce7ca2b01ffffffff0140420f00000000001976a914660d4ef3a743e3e696ad990364e555c271ad504b88ac00000000", "P2SH"],

["As above, but using a OP_1NEGATE"],
[[["60a20bd93aa49ab4b28d514ec10b06e1829ce6818ec06cd3aabd013ebcdc4bb1", 0, "1 0x41 0x04cc71eb30d653c0c3163990c47b976f3fb3f37cccdcbedb169a1dfef58bbfbfaff7d8a473e7e2e6d317b87bafe8bde97e3cf8f065dec022b51d11fcdd0d348ac4 0x41 0x0461cbdcc5409fb4b4d42b51d33381354d80e550078cb532a34bfa2fcfdeb7d76519aecc62770f5b0e4ef8551946d8a540911abe3e7854a26f39f58b25c15342af 2 OP_CHECKMULTISIG"]],
"0100000001b14bdcbc3e01bdaad36cc08e81e69c82e1060bc14e518db2b49aa43ad90ba26000000000494f47304402203f16c6f40162ab686621ef3000b04e75418a0c0cb2d8aebeac894ae360ac1e780220ddc15ecdfc3507ac48e1681a33eb60996631bf6bf5bc0a0682c4db743ce7ca2b01ffffffff0140420f00000000001976a914660d4ef3a743e3e696ad990364e555c271ad504b88ac00000000", "P2SH"],

>>>>>>> origin/0.11.2-wrapper

Updated to head


Removing src/test/data/sig_noncanonical.json
Removing src/test/data/sig_canonical.json
Auto-merging src/test/data/script_valid.json

CONFLICT (content): Merge conflict in src/test/data/script_valid.json

Updated to head

Auto-merging src/test/data/script_invalid.json

CONFLICT (content): Merge conflict in src/test/data/script_invalid.json

Updated to Head0.9.6.2


Removing src/test/data/README.md
Removing src/test/canonical_tests.cpp

CONFLICT (modify/delete): src/test/bloom_tests.cpp deleted in HEAD and modified in origin/0.11.2-wrapper. Version origin/0.11.2-wrapper of src/test/bloom_tests.cpp left in tree.

Deleted

Removing src/test/bignum_tests.cpp
Auto-merging src/test/base58_tests.cpp



CONFLICT (content): Merge conflict in src/test/base58_tests.cpp

<<<<<<< HEAD
                            EncodeBase58(&sourcedata[0], &sourcedata[sourcedata.size()]) == base58string,
                            strTest);
=======
                    EncodeBase58(begin_ptr(sourcedata), end_ptr(sourcedata)) == base58string,
                    strTest);
>>>>>>> origin/0.11.2-wrapper

Updated to Head




SelectParams(CBaseChainParams::MAIN);  

LEFT in from 0.11 





CONFLICT (modify/delete): src/test/alert_tests.cpp deleted in HEAD and modified in origin/0.11.2-wrapper. Version origin/0.11.2-wrapper of src/test/alert_tests.cpp left in tree.

CONFLICT (modify/delete): src/test/README deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/test/README left in tree.

CONFLICT (modify/delete): src/test/Makefile.am deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/test/Makefile.am left in tree.


Deleted



Auto-merging src/test/DoS_tests.cpp

CONFLICT (content): Merge conflict in src/test/DoS_tests.cpp



updated to head


Auto-merging src/test/Checkpoints_tests.cpp

CONFLICT (content): Merge conflict in src/test/Checkpoints_tests.cpp

<<<<<<< HEAD
    uint256 p1 = uint256("0xfdbe99b90c90bae7505796461471d89ae8388ab953997aa06a355bbda8d915cb");
    uint256 p41300 = uint256("0x8c4e02f6c0d20e856fd7e952a147fee30ce145ca6932a284f354924362d2b408");
    BOOST_CHECK(Checkpoints::CheckBlock(1, p1));
    BOOST_CHECK(Checkpoints::CheckBlock(41300, p41300));

    
    // Wrong hashes at checkpoints should fail:
    BOOST_CHECK(!Checkpoints::CheckBlock(1, p41300));
    BOOST_CHECK(!Checkpoints::CheckBlock(41300, p1));

    // ... but any hash not at a checkpoint should succeed:
    BOOST_CHECK(Checkpoints::CheckBlock(1+1, p41300));
    BOOST_CHECK(Checkpoints::CheckBlock(41300+1, p1));

    BOOST_CHECK(Checkpoints::GetTotalBlocksEstimate() >= 40000);
=======
    const Checkpoints::CCheckpointData& checkpoints = Params(CBaseChainParams::MAIN).Checkpoints();
    uint256 p11111 = uint256S("0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d");
    uint256 p134444 = uint256S("0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe");
    BOOST_CHECK(Checkpoints::CheckBlock(checkpoints, 11111, p11111));
    BOOST_CHECK(Checkpoints::CheckBlock(checkpoints, 134444, p134444));

    
    // Wrong hashes at checkpoints should fail:
    BOOST_CHECK(!Checkpoints::CheckBlock(checkpoints, 11111, p134444));
    BOOST_CHECK(!Checkpoints::CheckBlock(checkpoints, 134444, p11111));

    // ... but any hash not at a checkpoint should succeed:
    BOOST_CHECK(Checkpoints::CheckBlock(checkpoints, 11111+1, p134444));
    BOOST_CHECK(Checkpoints::CheckBlock(checkpoints, 134444+1, p11111));

    BOOST_CHECK(Checkpoints::GetTotalBlocksEstimate(checkpoints) >= 134444);
>>>>>>> origin/0.11.2-wrapper

updated to head


BOOST_AUTO_TEST_CASE(DoS_checkSig)
{  etc added

Updated to Head



Auto-merging src/support/pagelocker.h
Auto-merging src/support/pagelocker.cpp
Auto-merging src/script/standard.cpp

CONFLICT (content): Merge conflict in src/script/standard.cpp

Updated to head


Auto-merging src/script/script.h

CONFLICT (content): Merge conflict in src/script/script.h

??? done?


Auto-merging src/rpcserver.h

CONFLICT (content): Merge conflict in src/rpcserver.h


???? done?

Auto-merging src/rpcserver.cpp

CONFLICT (content): Merge conflict in src/rpcserver.cpp

??? done?


Auto-merging src/rpcrawtransaction.cpp

CONFLICT (content): Merge conflict in src/rpcrawtransaction.cpp

<<<<<<< HEAD
        int64_t nValue = out.tx->vout[out.i].nValue;
        const CScript& pk = out.tx->vout[out.i].scriptPubKey;
        Object entry;
        entry.push_back(Pair("txid", out.tx->GetHash().GetHex()));
        entry.push_back(Pair("vout", out.i));
        CTxDestination address;
        if (ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))
        {
            entry.push_back(Pair("address", CBitcoinAddress(address).ToString()));
            if (pwalletMain->mapAddressBook.count(address))
                entry.push_back(Pair("account", pwalletMain->mapAddressBook[address].name));
        }
        entry.push_back(Pair("scriptPubKey", HexStr(pk.begin(), pk.end())));
        if (pk.IsPayToScriptHash())
        {
            CTxDestination address;
            if (ExtractDestination(pk, address))
            {
#warning BOOST_VERSION      
#if ((BOOST_VERSION / 100000 == 1) && (BOOST_VERSION / 100 % 1000 == 58))
		  const CScriptID& hash = boost::get<const CScriptID>(address);
#else
		  const CScriptID& hash = boost::get<const CScriptID&>(address);
#endif
                CScript redeemScript;
                if (pwalletMain->GetCScript(hash, redeemScript))
                    entry.push_back(Pair("redeemScript", HexStr(redeemScript.begin(), redeemScript.end())));
            }
        }
        entry.push_back(Pair("amount",ValueFromAmount(nValue)));
        entry.push_back(Pair("confirmations",out.nDepth));
        results.push_back(entry);
    }
=======
    CDataStream ssMB(ParseHexV(params[0], "proof"), SER_NETWORK, PROTOCOL_VERSION);
    CMerkleBlock merkleBlock;
    ssMB >> merkleBlock;

    Array res;

    vector<uint256> vMatch;
    if (merkleBlock.txn.ExtractMatches(vMatch) != merkleBlock.header.hashMerkleRoot)
        return res;

    LOCK(cs_main);

    if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found in chain");
>>>>>>> origin/0.11.2-wrapper

Left as 0.11




Auto-merging src/rpcnet.cpp

CONFLICT (content): Merge conflict in src/rpcnet.cpp

uped to head


Auto-merging src/rpcmisc.cpp

CONFLICT (content): Merge conflict in src/rpcmisc.cpp

-copyright


Auto-merging src/rpcclient.cpp

CONFLICT (content): Merge conflict in src/rpcclient.cpp

Updated to head for send alert


Auto-merging src/qt/walletmodel.h

CONFLICT (content): Merge conflict in src/qt/walletmodel.h

-copyright

Auto-merging src/qt/walletmodel.cpp

CONFLICT (content): Merge conflict in src/qt/walletmodel.cpp


updated -copyright



Auto-merging src/qt/utilitydialog.h

CONFLICT (content): Merge conflict in src/qt/utilitydialog.h

-copyright


Auto-merging src/qt/utilitydialog.cpp

CONFLICT (content): Merge conflict in src/qt/utilitydialog.cpp

Updated to head



Auto-merging src/qt/transactionview.cpp

CONFLICT (content): Merge conflict in src/qt/transactionview.cpp


Updated to head




Auto-merging src/qt/transactiondesc.cpp

CONFLICT (content): Merge conflict in src/qt/transactiondesc.cpp


Updated to head  coinbase update




Auto-merging src/qt/test/uritests.cpp

CONFLICT (modify/delete): src/qt/test/Makefile.am deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/test/Makefile.am left in tree.

Left in

Auto-merging src/qt/splashscreen.cpp

CONFLICT (content): Merge conflict in src/qt/splashscreen.cpp


Updated to Head


Auto-merging src/qt/snapwidget.h

CONFLICT (content): Merge conflict in src/qt/snapwidget.h

-copyright


Auto-merging src/qt/snapwidget.cpp

CONFLICT (content): Merge conflict in src/qt/snapwidget.cpp



Updated to Head




Removing src/qt/shiftdialog.h
Removing src/qt/shiftdialog.cpp
Auto-merging src/qt/sendcoinsdialog.cpp

CONFLICT (content): Merge conflict in src/qt/sendcoinsdialog.cpp

-Copyright


Removing src/qt/res/src/questionmark.svg
Removing src/qt/res/src/inout.svg
Removing src/qt/res/src/clock_green.svg
Removing src/qt/res/src/clock5.svg
Removing src/qt/res/src/clock4.svg
Removing src/qt/res/src/clock3.svg
Removing src/qt/res/src/clock2.svg
Removing src/qt/res/src/clock1.svg
Removing src/qt/res/src/bitcoin.svg
Removing src/qt/res/images/splash_testnet.png

CONFLICT (modify/delete): src/qt/res/images/splash.png deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/res/images/splash.png left in tree.

Good, new splash screen left



Auto-merging src/qt/res/images/paper_wallet.png

CONFLICT (content): Merge conflict in src/qt/res/images/paper_wallet.png
CONFLICT (modify/delete): src/qt/res/images/mainbg.png deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/res/images/mainbg.png left in tree.

good new paper wallet left in


Removing src/qt/res/images/coinnector.png
Removing src/qt/res/images/about_bitcoin.png
Auto-merging src/qt/res/images/about.png

CONFLICT (content): Merge conflict in src/qt/res/images/about.png




??? Is this new about check ...




CONFLICT (modify/delete): src/qt/res/images/LOGO.png deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/res/images/LOGO.png left in tree.

Good new Logo used

Removing src/qt/res/icons/toolbar_testnet.png

CONFLICT (modify/delete): src/qt/res/icons/shapeshift.png deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/res/icons/shapeshift.png left in tree.

Good new logo


Removing src/qt/res/icons/coinnector.png
Removing src/qt/res/icons/bitcoin_testnet.png

CONFLICT (modify/delete): src/qt/res/icons/bitcoin_testnet.ico deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/res/icons/bitcoin_testnet.ico left in tree.

Good new logo

Auto-merging src/qt/res/icons/bitcoin.png

CONFLICT (content): Merge conflict in src/qt/res/icons/bitcoin.png

??? Is this correct copy back.



Removing src/qt/res/fonts/ComicNeue-Regular.ttf
Removing src/qt/res/fonts/ComicNeue-Regular-Oblique.ttf
Removing src/qt/res/fonts/ComicNeue-Light.ttf
Removing src/qt/res/fonts/ComicNeue-Light-Oblique.ttf
Removing src/qt/res/fonts/ComicNeue-Bold.ttf
Removing src/qt/res/fonts/ComicNeue-Bold-Oblique.ttf
Removing src/qt/res/feathercoin-qt-res.rc
Auto-merging src/qt/reportview.h

CONFLICT (content): Merge conflict in src/qt/reportview.h




Auto-merging src/qt/qimagesource.cpp
Auto-merging src/qt/optionsdialog.cpp

CONFLICT (content): Merge conflict in src/qt/optionsdialog.cpp

Updated to Head



Auto-merging src/qt/multisigdialog.cpp
Removing src/qt/monitoreddatamapper.h
Removing src/qt/monitoreddatamapper.cpp
Removing src/qt/locale/bitcoin_de_AT.ts

CONFLICT (modify/delete): src/qt/forms/shiftdialog.ui deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/forms/shiftdialog.ui left in tree.

Left in for the moment check


Auto-merging src/qt/forms/sendcoinsdialog.ui

CONFLICT (content): Merge conflict in src/qt/forms/sendcoinsdialog.ui


Updated to Head


Auto-merging src/qt/forms/receivecoinsdialog.ui

CONFLICT (content): Merge conflict in src/qt/forms/receivecoinsdialog.ui

           <string>An optional message to attach to the payment request, which will be displayed when the request is opened. Note: The message will not be sent with the payment over the Feathercoin network.</string>

           Updated to Head



Auto-merging src/qt/forms/paperwalletdialog.ui
Auto-merging src/qt/forms/overviewpage.ui

CONFLICT (content): Merge conflict in src/qt/forms/overviewpage.ui




CONFLICT (modify/delete): src/qt/forms/opennamedialog.ui deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/forms/opennamedialog.ui left in tree.

Remerge nameview ---



Auto-merging src/qt/forms/helpmessagedialog.ui

CONFLICT (content): Merge conflict in src/qt/forms/helpmessagedialog.ui


updated to head


Auto-merging src/qt/forms/debugdialog.ui

CONFLICT (content): Merge conflict in src/qt/forms/debugdialog.ui

Updated to head


Auto-merging src/qt/forms/commentdialog.ui
Removing src/qt/forms/coinnectordialog.ui

CONFLICT (modify/delete): src/qt/forms/aboutdialog.ui deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/forms/aboutdialog.ui left in tree.
CONFLICT (modify/delete): src/qt/feathercoin.qrc deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/feathercoin.qrc left in tree.
CONFLICT (modify/delete): src/qt/coinnectordialog.h deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/coinnectordialog.h left in tree.
CONFLICT (modify/delete): src/qt/coinnectordialog.cpp deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/coinnectordialog.cpp left in tree.

Left in for the moments


Removing src/qt/bitcoinstrings.cpp

Auto-merging src/qt/bitcoingui.h

CONFLICT (content): Merge conflict in src/qt/bitcoingui.h

Added back from Head

    QAction *accountReportAction;
    QAction *bitmessageAction;
//   QAction *shapeshiftAction;



Retained 0.11 update :
    QAction *addressBookAction;
    QAction *debugAction;
    QAction *bitmessageAction;


<<<<<<< HEAD
    /** Visit Shapeshift' API */
 //   void openShapeshiftClicked();
    /** Visit Coinnector' API */
//    void openCoinnectorClicked();
        
#endif
=======

added back for the moment
    


Auto-merging src/qt/bitcoingui.cpp

CONFLICT (content): Merge conflict in src/qt/bitcoingui.cpp

<<<<<<< HEAD
    usedSendingAddressesAction = new QAction(QIcon(":/icons/send"), tr("&Sending addresses..."), this);
    usedSendingAddressesAction->setStatusTip(tr("Show the list of used sending addresses and labels"));
    usedReceivingAddressesAction = new QAction(QIcon(":/icons/receiving_addresses"), tr("&Receiving addresses..."), this);
=======
    usedSendingAddressesAction = new QAction(TextColorIcon(":/icons/address-book"), tr("&Sending addresses..."), this);
    usedSendingAddressesAction->setStatusTip(tr("Show the list of used sending addresses and labels"));
    usedReceivingAddressesAction = new QAction(TextColorIcon(":/icons/address-book"), tr("&Receiving addresses..."), this);
>>>>>>> origin/0.11.2-wrapper


Left as new Head commented incase ---   check 


    bitmessageAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_7));
    	
    /*
     * Shapeshift and coinnector don't work for feathercoin anymore
     * therefore remove the menu entries
     * 
    shapeshiftAction = new QAction(QIcon(":/icons/shapeshift"), tr("Shapeshift..."), this);
    shapeshiftAction->setStatusTip(tr("Exchange other coins with your feathercoin on Shapeshift"));
    shapeshiftAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_8));
    coinnectorAction = new QAction(QIcon(":/icons/coinnector"), tr("Coinnector..."), this);
    coinnectorAction->setStatusTip(tr("Exchange other coins with your feathercoin on Coinnector"));
    coinnectorAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_9));
    *
    */
    
    showHelpMessageAction = new QAction(QApplication::style()->standardIcon(QStyle::SP_MessageBoxInformation), tr("&Command-line options"), this);
    showHelpMessageAction->setStatusTip(tr("Show the Feathercoin Core help message to get a list with possible Feathercoin command-line options"));
    
    Added from Head   BITMESSAGE -- shapeshift for the moment
    
    
            connect(bitmessageAction, SIGNAL(triggered()), this, SLOT(openBitmessageClicked()));
//        connect(shapeshiftAction, SIGNAL(triggered()), this, SLOT(openShapeshiftClicked()));
//        connect(coinnectorAction, SIGNAL(triggered()), this, SLOT(openCoinnectorClicked()));
        connect(paperWalletAction, SIGNAL(triggered()), walletFrame, SLOT(printPaperWallets()));

        
        Added back for the moment check


    
    QMenu *advanced = appMenuBar->addMenu(tr("&Advanced"));
    if(walletFrame)
    {
        advanced->addAction(accountReportAction);
        advanced->addAction(multiSigAction);
        advanced->addSeparator();
        advanced->addAction(inertBlockChainAction);
        advanced->addAction(opennameAction);
    }
    
    QMenu *plugins = appMenuBar->addMenu(tr("&Plugins"));
    if(walletFrame)
    { 
        plugins->addAction(bitmessageAction);
        plugins->addSeparator();
     //   plugins->addAction(shapeshiftAction);
     //   plugins->addAction(coinnectorAction);
    }
    
=======
    settings->addAction(optionsAction);

>>>>>>> origin/0.11.2-wrapper


added bac fro head for moment


  <<<<<<< HEAD
    accountReportAction->setEnabled(enabled);
    bitmessageAction->setEnabled(enabled);
  //  shapeshiftAction->setEnabled(enabled);
  //  coinnectorAction->setEnabled(enabled);
    paperWalletAction->setEnabled(enabled);
=======
>>>>>>> origin/0.11.2-wrapper

Paper wallet added back   check was missing




<<<<<<< HEAD
/* 
 * Coinnector and shapeshift disabled
 * 
 * 
void BitcoinGUI::openShapeshiftClicked()
=======
void BitcoinGUI::showDebugWindow()
>>>>>>> origin/0.11.2-wrapper


added back for the moment


        
        

Auto-merging src/qt/bitcoin.cpp

CONFLICT (content): Merge conflict in src/qt/bitcoin.cpp


-copyright



Auto-merging src/qt/addressbookpage.cpp

CONFLICT (content): Merge conflict in src/qt/addressbookpage.cpp

<<<<<<< HEAD
#ifdef USE_QRCODE
#include "qrcodedialog.h"
#include "snapwidget.h"
#endif
=======
#include "signverifymessagedialog.h"
>>>>>>> origin/0.11.2-wrapper

add both  check  



void AddressBookPage::on_showQRCode_clicked()
{
#ifdef USE_QRCODE
    if(!model)
        return;
        
    QTableView *table = ui->tableView;
    QModelIndexList indexes = table->selectionModel()->selectedRows(AddressTableModel::Address);

    Q_FOREACH (const QModelIndex index, indexes)
    {
        QString address = index.data().toString();
        QString label = index.sibling(index.row(), 0).data(Qt::EditRole).toString();

        QRCodeDialog *dialog = new QRCodeDialog(address, label, tab == ReceivingTab, this);
        dialog->setModel(optionsModel);
        dialog->setAttribute(Qt::WA_DeleteOnClose);
        dialog->show();
    }
#endif
}

void AddressBookPage::on_importQRCodeButton_clicked()
{
#ifdef USE_ZXING
    SnapWidget* snap = new SnapWidget(this);
    connect(snap, SIGNAL(finished(QString)), this, SLOT(onSnapClosed(QString))); 
#endif
}

void AddressBookPage::onSnapClosed(QString privKey)
{
    if (privKey.size() > 0)
        //to do : some more parsing and validation is needed here
        //todo: prompt for a label
        //todo: display a dialog if it doesn't work
        Q_EMIT importWallet(privKey);
}
>>>>>>> origin/0.11.2-wrapper



Left this in  check




CONFLICT (modify/delete): src/qt/Makefile.am deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/qt/Makefile.am left in tree.

Left in for moment  check


Removing src/obj/.gitignore
Removing src/obj-test/.gitignore
Auto-merging src/net.cpp

CONFLICT (content): Merge conflict in src/net.cpp

<<<<<<< HEAD
=======
#include "crypto/common.h"
#include "primitives/block.h"
>>>>>>> origin/0.11.2-wrapper







Auto-merging src/miner.cpp

CONFLICT (content): Merge conflict in src/miner.cpp

<<<<<<< HEAD
// ScanHash_CryptoPP not used
//unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)
//{
//    unsigned int& nNonce = *(unsigned int*)(pdata + 12);
//    for (;;)
//    {
//        // Crypto++ SHA256
//        // Hash pdata using pmidstate as the starting state into
//        // pre-formatted buffer phash1, then hash phash1 into phash
//        nNonce++;
//        SHA256Transform(phash1, pdata, pmidstate);
//        SHA256Transform(phash, phash1, pSHA256InitState);
//
//        // Return the nonce if the hash has at least some zero bits,
//        // caller will check if it has enough to reach the target
//        if (((unsigned short*)phash)[14] == 0)
//            return nNonce;
//
//        // If nothing found after trying for a while, return -1
//        if ((nNonce & 0xffff) == 0)
//        {
//            nHashesDone = 0xffff+1;
//            return (unsigned int) -1;
//        }
//        if ((nNonce & 0xfff) == 0)
//            boost::this_thread::interruption_point();
//    }
//}
=======
bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)
{
    // Write the first 76 bytes of the block header to a double-SHA256 state.
    CHash256 hasher;
    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
    ss << *pblock;
    assert(ss.size() == 80);
    hasher.Write((unsigned char*)&ss[0], 76);

    while (true) {
        nNonce++;

        // Write the last 4 bytes of the block header (the nonce) to a copy of
        // the double-SHA256 state, and compute the result.
        CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);

        // Return the nonce if the hash has at least some zero bits,
        // caller will check if it has enough to reach the target
        if (((uint16_t*)phash)[15] == 0)
            return true;

        // If nothing found after trying for a while, return -1
        if ((nNonce & 0xfff) == 0)
            return false;
    }
}
>>>>>>> origin/0.11.2-wrapper

Left this in and head commented check 








Auto-merging src/main.h

CONFLICT (content): Merge conflict in src/main.h



??????



Auto-merging src/main.cpp

CONFLICT (content): Merge conflict in src/main.cpp



<<<<<<< HEAD
map<uint256, CBlock*> mapOrphanBlocksA;
map<uint256, COrphanBlock*> mapOrphanBlocks;
multimap<uint256, COrphanBlock*> mapOrphanBlocksByPrev;
=======
CTxMemPool mempool(::minRelayTxFee);
>>>>>>> origin/0.11.2-wrapper


Left both in ????   check




<<<<<<< HEAD
        if (!CheckInputs(tx, state, view, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC |SCRIPT_VERIFY_DERSIG))
=======
        if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))
        {
        		LogPrintf("AcceptToMemoryPool,STANDARD_SCRIPT_VERIFY_FLAGS=%i\n", STANDARD_SCRIPT_VERIFY_FLAGS);
            return error("AcceptToMemoryPool: ConnectInputs failed %s", hash.ToString());
        }

        // Check again against just the consensus-critical mandatory script
        // verification flags, in case of bugs in the standard flags that cause
        // transactions to pass as valid when they're actually invalid. For
        // instance the STRICTENC flag was incorrectly allowing certain
        // CHECKSIG NOT scripts to pass, even though they were invalid.
        //
        // There is a similar check in CreateNewBlock() to prevent creating
        // invalid blocks, however allowing such transactions into the mempool
        // can be exploited as a DoS attack.
        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true))
>>>>>>> origin/0.11.2-wrapper


Updated to head  version check  ????


=======
    if (fTxIndex) {
        CDiskTxPos postx;
        if (pblocktree->ReadTxIndex(hash, postx)) {
            CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION);
            if (file.IsNull())
                return error("%s: OpenBlockFile failed", __func__);
            CBlockHeader header;
            try {
                file >> header;
                fseek(file.Get(), postx.nTxOffset, SEEK_CUR);
                file >> txOut;
            } catch (const std::exception& e) {
                return error("%s: Deserialize or I/O error - %s", __func__, e.what());
>>>>>>> origin/0.11.2-wrapper

0.11 code removed



// pblockindexFBBHLast : no longer used 
// static CBlockIndex* pblockindexFBBHLast;
bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)
=======

bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos, const CMessageHeader::MessageStartChars& messageStart)
>>>>>>> origin/0.11.2-wrapper



Message start from 0.11 used



<<<<<<< HEAD
    if (mapOrphanBlocksByPrev.size() <= (size_t)std::max((int64_t)0, GetArg("-maxorphanblocks", DEFAULT_MAX_ORPHAN_BLOCKS)))
        return;

    // Pick a random orphan block.
    int pos = insecure_rand() % mapOrphanBlocksByPrev.size();
    std::multimap<uint256, COrphanBlock*>::iterator it = mapOrphanBlocksByPrev.begin();
    while (pos--) it++;

    // As long as this block has other orphans depending on it, move to one of those successors.
    do {
        std::multimap<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocksByPrev.find(it->second->hashBlock);
        if (it2 == mapOrphanBlocksByPrev.end())
            break;
        it = it2;
    } while(1);

    uint256 hash = it->second->hashBlock;
    delete it->second;
    mapOrphanBlocksByPrev.erase(it);
    mapOrphanBlocks.erase(hash);
}

int64_t GetBlockValue(int nHeight, int64_t nFees)
{    
    int64_t nSubsidy = 200 * COIN;
	
		if(nHeight >= nForkThree || (TestNet()))
			nSubsidy = 80 * COIN;

    // Halving subsidy happens every 2,100,000 blocks. The code below takes account for the
    // fact that the first 204,639 blocks took 2.5 minutes and after changed to 1 minute.
    nSubsidy >>= (nHeight + 306960) / 2100000;

    return nSubsidy + nFees;
}

// Feathercoin: eHRC at 3rd hard fork
int nTargetTimespan = 3.5 * 24 * 60 * 60; // 3.5 days
int nTargetSpacing = 2.5 * 60; // 2.5 minutes
//static const int64_t nInterval = nTargetTimespan / nTargetSpacing;

//
// minimum amount of work that could possibly be required nTime after
// minimum work required was nBase
//
unsigned int ComputeMinWork(unsigned int nBase, int64_t nTime)
{
    const CBigNum &bnLimit = Params().ProofOfWorkLimit();
    // Testnet has min-difficulty blocks
    // after nTargetSpacing*2 time between blocks:
    if (TestNet() && nTime > nTargetSpacing*2)
        return bnLimit.GetCompact();

    CBigNum bnResult;
    bnResult.SetCompact(nBase);
    while (nTime > 0 && bnResult < bnLimit)
    {
        // Maximum 400% adjustment...
        bnResult *= 4;
        // ... in best-case exactly 4-times-normal target time
        nTime -= nTargetTimespan*4;
    }
    if (bnResult > bnLimit)
        bnResult = bnLimit;
    return bnResult.GetCompact();
}

unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)
{
    unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit().GetCompact();

    // Genesis block
    if (pindexLast == NULL)
        return nProofOfWorkLimit;

    // The next block
    int nHeight = pindexLast->nHeight + 1;
    LogPrintf("GetNextWorkRequired pindexLast block Height=%d,nBits=%d \n",pindexLast->nHeight,pindexLast->nBits);
    LogPrintf("GetNextWorkRequired the next block Height=%d \n",nHeight);

    /* The 4th hard fork and testnet hard fork */
    if((nHeight >= nForkFour) || (TestNet() && (nHeight >= nTestnetFork))) {
        if(!fNeoScrypt) fNeoScrypt = true;
        /* Difficulty reset after the switch */
        if((nHeight == nForkFour) || (TestNet() && (nHeight == nTestnetFork)))
          return(bnNeoScryptSwitch.GetCompact());
    }
    LogPrintf("GetNextWorkRequired fork\n");
    
    if (nHeight >= nForkOne)
			nTargetTimespan = (7 * 24 * 60 * 60) / 8; // 7/8 days

    if (nHeight >= nForkTwo)
			nTargetTimespan = (7 * 24 * 60 * 60) / 32; // 7/32 days
		
    if (nHeight >= nForkThree || TestNet()) {
        nTargetTimespan = 60; // 1 minute timespan
        nTargetSpacing = 60; // 1 minute block
    }

    // 2016 blocks initial, 504 after the 1st, 126 after the 2nd hard fork, 15 after the 3rd hard fork
    int nInterval = nTargetTimespan / nTargetSpacing;

    bool fHardFork = (nHeight == nForkOne) || (nHeight == nForkTwo) || (nHeight == nForkThree) || (nHeight == nForkFour);
    if(TestNet()) {
        if (nHeight == nTestnetFork) {
            fHardFork = true;
        } else {
            fHardFork = false;
        }
    }
    	
    	
    // Difficulty rules regular blocks
    if((nHeight % nInterval != 0) && !(fHardFork) && (nHeight < nForkThree))
    {
        if (TestNet())
        {
            // Special difficulty rule for testnet:
            // If the new block's timestamp is more than 2* 10 minutes
            // then allow mining of a min-difficulty block.
            if (pblock->nTime > pindexLast->nTime + nTargetSpacing*2)
                return nProofOfWorkLimit;
            else
            {
                // Return the last non-special-min-difficulty-rules-block
                const CBlockIndex* pindex = pindexLast;
                while (pindex->pprev && pindex->nHeight % nInterval != 0 && pindex->nBits == nProofOfWorkLimit)
                    pindex = pindex->pprev;
                return pindex->nBits;
            }
        }
        return pindexLast->nBits;
    }
    LogPrintf("Difficulty rules regular blocks \n");
    
    // The 1st retarget after genesis
    if(nInterval >= nHeight) nInterval = nHeight - 1;    

    // Go back by nInterval
    const CBlockIndex* pindexFirst = pindexLast;
    for (int i = 0; pindexFirst && i < nInterval; i++)
        pindexFirst = pindexFirst->pprev;
    assert(pindexFirst);

    // Limit adjustment step
    int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();
    LogPrintf("GetNextWorkRequired(), nActualTimespan = %d  before bounds\n", nActualTimespan);
    
    // Additional averaging over 4x nInterval window
    if((nHeight >= nForkTwo) && (nHeight < nForkThree)) {
        nInterval *= 4;

        const CBlockIndex* pindexFirst = pindexLast;
        for(int i = 0; pindexFirst && i < nInterval; i++)
          pindexFirst = pindexFirst->pprev;

        int nActualTimespanLong =
          (pindexLast->GetBlockTime() - pindexFirst->GetBlockTime())/4;

        // Average between short and long windows
        int nActualTimespanAvg = (nActualTimespan + nActualTimespanLong)/2;

        // Apply .25 damping
        nActualTimespan = nActualTimespanAvg + 3*nTargetTimespan;
        nActualTimespan /= 4;

        LogPrintf("RETARGET: nActualTimespanLong = %d, nActualTimeSpanAvg = %d, nActualTimespan (damped) = %d\n",
          nActualTimespanLong, nActualTimespanAvg, nActualTimespan);
    }
    
  //eHRC  
	// Additional averaging over 15, 120 and 480 block window
    if((nHeight >= nForkThree) || TestNet()) {
	
        nInterval *= 480;

        int pindexFirstShortTime = 0;
        int pindexFirstMediumTime = 0;
        const CBlockIndex* pindexFirstLong = pindexLast;
		for(int i = 0; pindexFirstLong && i < nInterval && i < nHeight - 1; i++) {  // i < nHeight - 1 special rule for testnet
			pindexFirstLong = pindexFirstLong->pprev;
			if (i == 14) {
                pindexFirstShortTime = pindexFirstLong->GetBlockTime();
			}
			if (i == 119) {
                pindexFirstMediumTime = pindexFirstLong->GetBlockTime();
			}
		}

		int nActualTimespanShort =
            (pindexLast->GetBlockTime() - pindexFirstShortTime)/15;
		
		int nActualTimespanMedium =
            (pindexLast->GetBlockTime() - pindexFirstMediumTime)/120;

        int nActualTimespanLong =
			(pindexLast->GetBlockTime() - pindexFirstLong->GetBlockTime())/480;

        int nActualTimespanAvg = 0;
        nActualTimespanAvg = (nActualTimespanShort + nActualTimespanMedium + nActualTimespanLong)/3;

		// Apply .25 damping
		nActualTimespan = nActualTimespanAvg + 3*nTargetTimespan;
		nActualTimespan /= 4;

		LogPrintf("RETARGET: nActualTimespanShort = %d, nActualTimespanMedium = %d, nActualTimespanLong = %d, nActualTimeSpanAvg = %d, nActualTimespan (damped) = %d\n",
		nActualTimespanShort, nActualTimespanMedium, nActualTimespanLong, nActualTimespanAvg, nActualTimespan);
    }

    // The initial settings (4.0 difficulty limiter)
    int nActualTimespanMax = nTargetTimespan*4;
    int nActualTimespanMin = nTargetTimespan/4;

    // The 1st hard fork (1.4142857 aka 41% difficulty limiter)
    if(nHeight >= nForkOne) {
        nActualTimespanMax = nTargetTimespan*99/70;
        nActualTimespanMin = nTargetTimespan*70/99;
    }

    // The 2nd hard fork (1.0905077 aka 9% difficulty limiter)
    if(nHeight >= nForkTwo || TestNet()) {
        nActualTimespanMax = nTargetTimespan*494/453;
        nActualTimespanMin = nTargetTimespan*453/494;
    }

    if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;
    if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;

    LogPrintf("RETARGET: nActualTimespan = %d after bounds\n", nActualTimespan);
    LogPrintf("RETARGET: nTargetTimespan = %d, nTargetTimespan/nActualTimespan = %.4f\n", nTargetTimespan, (float) nTargetTimespan/nActualTimespan);


    // Retarget
    CBigNum bnNew;
    bnNew.SetCompact(pindexLast->nBits);
    //watch
    bnNew *= nActualTimespan;
    bnNew /= nTargetTimespan;

    if (bnNew > Params().ProofOfWorkLimit())
        bnNew = Params().ProofOfWorkLimit();

    /// debug print
    LogPrintf("GetNextWorkRequired RETARGET\n");
    LogPrintf("nTargetTimespan = %d    nActualTimespan = %d\n", nTargetTimespan, nActualTimespan);
    LogPrintf("Before: %08x  %s\n", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString());
    LogPrintf("After:  %08x  %s\n", bnNew.GetCompact(), bnNew.getuint256().ToString());

    return bnNew.GetCompact();
}

bool CheckProofOfWork(uint256 hash, unsigned int nBits)
{
    CBigNum bnTarget;
    bnTarget.SetCompact(nBits);

    // Check range
    if (bnTarget <= 0 || bnTarget > Params().ProofOfWorkLimit())
        return error("Check range CheckProofOfWork() : nBits below minimum work");

    // Check proof of work matches claimed amount
    //LogPrintf("CheckProofOfWork() hash=%s \n",hash.ToString().c_str());
    //LogPrintf("CheckProofOfWork() nBits=%i \n",nBits);
    //LogPrintf("CheckProofOfWork() bnTarget.getuint256=%s \n",bnTarget.getuint256().ToString().c_str());
    if (hash > bnTarget.getuint256())
        return error("matches claimed amount, CheckProofOfWork() : hash doesn't match nBits");

    return true;
}

bool IsInitialBlockDownload()
{
    LOCK(cs_main);
    if (fImporting || fReindex || chainActive.Height() < Checkpoints::GetTotalBlocksEstimate())
        return true;
    static int64_t nLastUpdate;
    static CBlockIndex* pindexLastBest;
    if (chainActive.Tip() != pindexLastBest)
    {
        pindexLastBest = chainActive.Tip();
        nLastUpdate = GetTime();
    }
    return (GetTime() - nLastUpdate < 10 &&
            chainActive.Tip()->GetBlockTime() < GetTime() - 24 * 60 * 60);
=======
    const CChainParams& chainParams = Params();
    LOCK(cs_main);
    if (fImporting || fReindex)
        return true;
    if (fCheckpointsEnabled && chainActive.Height() < Checkpoints::GetTotalBlocksEstimate(chainParams.Checkpoints()))
        return true;
    static bool lockIBDState = false;
    if (lockIBDState)
        return false;
    bool state = (chainActive.Height() < pindexBestHeader->nHeight - 24 * 6 ||
            pindexBestHeader->GetBlockTime() < GetTime() - chainParams.MaxTipAge());
    if (!state)
        lockIBDState = true;
    return state;
>>>>>>> origin/0.11.2-wrapper



0.11 version taken bbut   check   has forks in now removed ?????


<<<<<<< HEAD
            if (coins.IsCoinBase()) {
            	
            	  int minDepth = GetRequiredMaturityDepth(coins.nHeight);            	  
                //if (nSpendHeight - coins.nHeight < COINBASE_MATURITY)
                if (nSpendHeight - coins.nHeight < minDepth)
=======
            if (coins->IsCoinBase()) {
            		int minDepth = GetRequiredMaturityDepth(coins->nHeight);            		
                if (nSpendHeight - coins->nHeight < minDepth)
>>>>>>> origin/0.11.2-wrapper



Include coinbase fix check ?????


<<<<<<< HEAD
    	if (pindexNew->pprev && !CheckSyncCheckpoint(pindexNew->GetBlockHash(), pindexNew->pprev))
=======
    	if (pindexBestHeader->pprev && !CheckSyncCheckpoint(pindexBestHeader->GetBlockHash(), pindexBestHeader->pprev))
>>>>>>> origin/0.11.2-wrapper


Pulled from head   check ?????



<<<<<<< HEAD
  
//for 0.8.7 ACP
bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)
{
=======


//for 0.8.7 ACP
bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)
{
		const CChainParams& chainParams = Params();  
		
>>>>>>> origin/0.11.2-wrapper

has this been removed check   - left as 0.11  for moment ?????



<<<<<<< HEAD
=======
		//hard retuen 
		if (pindexNew->GetBlockHash() == hardhashCheckpoint) {
				LogPrintf("SetBestChain:101  hard return\n");	
				return true;
		}
				
>>>>>>> origin/0.11.2-wrapper

Left as 0.11 for moment check ?????



<<<<<<< HEAD
        			
    // All modifications to the coin state will be done in this cache.
    // Only when all have succeeded, we push it to pcoinsTip.
    CCoinsViewCache view(*pcoinsTip, true);

    // Find the fork (ä»pindexOldTipéå°pindexNew)  
=======
    // rollback
    if (pindexNew->nHeight - pindexOldTip->nHeight >= 1)
    		return true;
        			
    // All modifications to the coin state will be done in this cache.
    // Only when all have succeeded, we push it to pcoinsTip.
    CCoinsViewCache view(pcoinsTip);
    
    // Find the fork (ŽÓpindexOldTipÍËµœpindexNew)  
>>>>>>> origin/0.11.2-wrapper

update to head check ????





<<<<<<< HEAD
    // List of what to disconnect (ä»pindexOldTipéå°pindexNew=pfork)
=======
    // List of what to disconnect (ŽÓpindexOldTipÍËµœpindexNew=pfork)
>>>>>>> origin/0.11.2-wrapper


update to head check ????




<<<<<<< HEAD
        LogPrintf("SetBestChain:120: Disconnect %" PRIszu " blocks; %s...\n", vDisconnect.size(), pfork->GetBlockHash().ToString());
        LogPrintf("SetBestChain:120: Connect %" PRIszu " blocks; ...%s\n", vConnect.size(), pindexNew->GetBlockHash().ToString());
    }
    
    
    // Disconnect shorter branch
    vector<CTransaction> vResurrect;
    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {
        CBlock block;
        if (!ReadBlockFromDisk(block, pindex))
            return state.Abort(_("Failed to read block"));
        int64 nStart = GetTimeMicros();
=======
        LogPrintf("SetBestChain:120: Disconnect %d blocks; %s...\n", vDisconnect.size(), pfork->GetBlockHash().ToString());
        LogPrintf("SetBestChain:120: Connect %d blocks; ...%s\n", vConnect.size(), pindexNew->GetBlockHash().ToString());
    }

    // Disconnect shorter branch
    vector<CTransaction> vResurrect;
    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {        
        LogPrintf("SetBestChain:121,pindex->nHeight=%d,pindex->blockhash=%s\n",pindex->nHeight,pindex->GetBlockHash().ToString());
        CDiskBlockPos pos = pindex->GetUndoPos();
        LogPrintf("SetBestChain:122,pos=%s\n",pos.ToString());
        
        CBlock block;
        if (!ReadBlockFromDisk(block, pindex))
            return AbortNode(state, "Failed to read block");
        int64_t nStart = GetTimeMicros();
>>>>>>> origin/0.11.2-wrapper


update to head   check ?????



            if (!tx.IsCoinBase() && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())
                vResurrect.push_back(tx);
    }
    
=======
            if (!tx.IsCoinBase() && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate(chainParams.Checkpoints()))
                vResurrect.push_back(tx);
    }

>>>>>>> origin/0.11.2-wrapper



Update to head ??? check






<<<<<<< HEAD
            return state.Abort(_("Failed to read block"));
        int64 nStart = GetTimeMicros();
        if (!ConnectBlock(block, state, pindex, view)) {
            if (state.IsInvalid()) {
                InvalidChainFound(pindexNew);
                InvalidBlockFound(pindex,state);
            }
            return error("SetBestBlock() : ConnectBlock %s failed", pindex->GetBlockHash().ToString().c_str());
        }
        if (fBenchmark)
            LogPrintf("- Connect: %.2fms\n", (GetTimeMicros() - nStart) * 0.001);

        // Queue memory transactions to delete
        BOOST_FOREACH(const CTransaction& tx, block.vtx)
            vDelete.push_back(tx);
    }
    LogPrintf("SetBestChain:130: \n");
    
    // Flush changes to global coin state
    int64 nStart = GetTimeMicros();
    int nModified = view.GetCacheSize();
    assert(view.Flush());
    int64 nTime = GetTimeMicros() - nStart;
    if (fBenchmark)
        LogPrintf("- Flush %i transactions: %.2fms (%.4fms/tx)\n", nModified, 0.001 * nTime, 0.001 * nTime / nModified);    
    
    if (!WriteChainState(state))
        return false;
        
    // Resurrect memory transactions that were in the disconnected branch
    BOOST_FOREACH(CTransaction& tx, vResurrect) {
        // ignore validation errors in resurrected transactions
        CValidationState stateDummy;
        list<CTransaction> removed;
        if (!AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))
            mempool.remove(tx, removed, true);               
    }
    
    // Delete redundant memory transactions that are in the connected branch
    list<CTransaction> txConflicted;
    BOOST_FOREACH(CTransaction& tx, vDelete) {
        list<CTransaction> removed;
        mempool.remove(tx, removed);
        mempool.removeConflicts(tx, txConflicted);
    }
    
    mempool.check(pcoinsTip);
    LogPrintf("SetBestChain:140: \n");
    
    UpdateTip(pindexNew);
    
    // Tell wallet about transactions that went from mempool to conflicted:
    BOOST_FOREACH(const CTransaction &tx, txConflicted) {
        SyncWithWallets(tx.GetHash(), tx, NULL);
    }
    
		LogPrintf("SetBestChain:150 true.\n");
    return true;
}

// Try to activate to the most-work chain (thereby connecting it).
bool ActivateBestChain(CValidationState &state) {
    LOCK(cs_main);
    CBlockIndex *pindexOldTip = chainActive.Tip();
    bool fComplete = false;
    while (!fComplete) {
        FindMostWorkChain();
        fComplete = true;

        // Check whether we have something to do.
        if (chainMostWork.Tip() == NULL) break;

        // Disconnect active blocks which are no longer in the best chain.
        while (chainActive.Tip() && !chainMostWork.Contains(chainActive.Tip())) {
            if (!DisconnectTip(state))
                return false;
        }

        // Connect new blocks.
        while (!chainActive.Contains(chainMostWork.Tip())) {
            CBlockIndex *pindexConnect = chainMostWork[chainActive.Height() + 1];
            if (!ConnectTip(state, pindexConnect)) {
                if (state.IsInvalid()) {
                    // The block violates a consensus rule.
                    if (!state.CorruptionPossible())
                        InvalidChainFound(chainMostWork.Tip());
                    fComplete = false;
                    state = CValidationState();
                    break;
                } else {
                    // A system error occurred (disk space, database error, ...).
                    return false;
                }
=======
            return AbortNode(state, "Failed to read block");
        int64_t nStart = GetTimeMicros();
        if (!ConnectBlock(block, state, pindex, view)) {
            if (state.IsInvalid()) {
            		LogPrintf("SetBestChain,InvalidChainFound,InvalidBlockFound.\n");
                InvalidChainFound(pindexNew);
                InvalidBlockFound(pindex,state);
>>>>>>> origin/0.11.2-wrapper





Update to head








<<<<<<< HEAD
// to enable merged mining:
// - set a block from which it will be enabled
// - set a unique chain ID
//   (if two have the same ID, they can't be merge mined together)
int GetAuxPowStartBlock()
{
    if (TestNet())
        return AUXPOW_START_TESTNET;
    else
        return AUXPOW_START_MAINNET;
}

bool CBlockHeader::CheckProofOfWork(int nHeight) const
{	
	//LogPrintf("CBlockHeader::CheckProofOfWork(), nHeight=%i \n",nHeight);
	if (TestNet())
	{
		 //work in testnet
			if (nHeight==INT_MAX)
			{
					if (!::CheckProofOfWork(GetPoWHashS(), nBits))
					{
							if (!::CheckProofOfWork(GetPoWHash(), nBits))
							{
									LogPrintf("CBlockHeader::CheckProofOfWork(),GetPoWHash, nHeight=%i \n",nHeight);
							    return error("CBlockHeader::CheckProofOfWork() GetPoWHash: INT_MAX proof of work failed.");	
							}
					}
					return true;
			}			
			if (nHeight>=600)
			{
				if (!::CheckProofOfWork(GetPoWHash(), nBits))
				{
						LogPrintf("CBlockHeader::CheckProofOfWork(),GetPoWHash in testnet, nHeight=%i \n",nHeight);
				    return error("CBlockHeader::CheckProofOfWork() GetPoWHash in testnet: proof of work failed.");	
				}
			}
			else
			{
				if (!::CheckProofOfWork(GetPoWHashS(), nBits))
				{
						LogPrintf("CBlockHeader::CheckProofOfWork(),GetPoWHashS in testnet, nHeight=%i \n",nHeight);
				    return error("CBlockHeader::CheckProofOfWork() GetPoWHashS in testnet: proof of work failed.");	
				}
			}
	}
	else
	{
		  //work in mainnet
			if (nHeight==INT_MAX)
			{
					if (!::CheckProofOfWork(GetPoWHashS(), nBits))
					{
							if (!::CheckProofOfWork(GetPoWHash(), nBits))
							{
									LogPrintf("CBlockHeader::CheckProofOfWork(),GetPoWHash, nHeight=%i \n",nHeight);
							    return error("CBlockHeader::CheckProofOfWork() GetPoWHash: INT_MAX proof of work failed.");	
							}
					}
					return true;
			}	
			if (nHeight>=nForkFour)
			{
				if (!::CheckProofOfWork(GetPoWHash(), nBits))
				{
						LogPrintf("CBlockHeader::CheckProofOfWork(),GetPoWHash in mainnet, nHeight=%i \n",nHeight);
				    return error("CBlockHeader::CheckProofOfWork() GetPoWHash in mainnet: proof of work failed.");	
				}
			}
			else
			{
				if (!::CheckProofOfWork(GetPoWHashS(), nBits))
				{
						LogPrintf("CBlockHeader::CheckProofOfWork(),GetPoWHashS in mainnet, nHeight=%i \n",nHeight);
				    return error("CBlockHeader::CheckProofOfWork() GetPoWHashS in mainnet: proof of work failed.");	
				}
			}
	}
	return true;
}

=======


Update to head   check ????






<<<<<<< HEAD
                             


        // ppcoin: check that the block satisfies synchronized checkpoint
        // if not in checkpoint advisory mode
        if (IsSyncCheckpointEnforced() && !CheckSyncCheckpoint(hash, pindexPrev))
        	return error("checkpoint AcceptBlock() : rejected by synchronized checkpoint");

=======

        // ppcoin: check that the block satisfies synchronized checkpoint
        // checkpoint advisory mode
        if (!IsSyncCheckpointEnforced() && !CheckSyncCheckpoint(hash, pindexPrev))
        	return error("checkpoint ContextualCheckBlockHeader() : rejected by synchronized checkpoint");
        	
>>>>>>> origin/0.11.2-wrapper



update to head





<<<<<<< HEAD

    uint256 hash = pindex->GetBlockHash();

    // Check that all transactions are finalized
    BOOST_FOREACH(const CTransaction& tx, block.vtx)
        if (!IsFinalTx(tx, nHeight, block.GetBlockTime())) {
            pindex->nStatus |= BLOCK_FAILED_VALID;
            return state.DoS(10, error("AcceptBlock() : contains a non-final transaction"),
                             REJECT_INVALID, "bad-txns-nonfinal");
        }

    // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height
    if (block.nVersion == 2 && block.nTime > nSwitchV2 ) 
    {
        // if 750 of the last 1,000 blocks are version 2 or greater (51/100 if testnet):
        if ((!TestNet() && CBlockIndex::IsSuperMajority(2, pindex->pprev, 750, 1000)) ||
            (TestNet() && CBlockIndex::IsSuperMajority(2, pindex->pprev, 51, 100)))
        {
            CScript expect = CScript() << nHeight;
            if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||
                !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin())) 
            {
                pindex->nStatus |= BLOCK_FAILED_VALID;
                LogPrintf("AcceptBlock() block.nVersion=%d,nHeight=%d:\n",block.nVersion,nHeight);
                LogPrintf("AcceptBlock() block.vtx[0].vin[0].scriptSig.size()=%d,expect.size()=%d:\n",block.vtx[0].vin[0].scriptSig.size(),expect.size());
                return state.DoS(100, error("AcceptBlock() : block nVersion 2 height mismatch in coinbase"),
                                 REJECT_INVALID, "bad-cb-height");
            }
        }
    }
    
    if (block.nVersion == 4 )
    {
        // if 750 of the last 1,000 blocks are version 2 or greater (51/100 if testnet):
        if ((!TestNet() && CBlockIndex::IsSuperMajority(2, pindex->pprev, 750, 1000)) ||
            (TestNet() && CBlockIndex::IsSuperMajority(2, pindex->pprev, 51, 100)))
        {
            CScript expect = CScript() << nHeight;
            if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||
                !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin())) 
            {
                pindex->nStatus |= BLOCK_FAILED_VALID;
                LogPrintf("AcceptBlock() block.nVersion=%d,nHeight=%d:\n",block.nVersion,nHeight);
                LogPrintf("AcceptBlock() block.vtx[0].vin[0].scriptSig.size()=%d,expect.size()=%d:\n",block.vtx[0].vin[0].scriptSig.size(),expect.size());
                return state.DoS(100, error("AcceptBlock() : block nVersion 4 height mismatch in coinbase"),
                                 REJECT_INVALID, "bad-cb-height");
            }
        }
=======
    else
    {
    	//LogPrintf("AcceptBlock CheckBlock true,nHeight=%d.\n",pindex->nHeight);
>>>>>>> origin/0.11.2-wrapper



Update to head check ?????




    // Feathercoin: temporarily disable v2 block lockin until we are ready for v2 transition
    // 1000äžªäž­æ750äžªæ°çæ¬
    // return false;
    
=======
>>>>>>> origin/0.11.2-wrapper


update to head but comment ony check ????




<<<<<<< HEAD
bool CBlockIndex::IsInMainChain() const
{
		return chainActive.Contains(this);
}

int64_t CBlockIndex::GetMedianTime() const
{
    AssertLockHeld(cs_main);
    const CBlockIndex* pindex = this;
    for (int i = 0; i < nMedianTimeSpan/2; i++)
    {
        if (!chainActive.Next(pindex))
            return GetBlockTime();
        pindex = chainActive.Next(pindex);
    }
    return pindex->GetMedianTimePast();
}

std::string CBlockIndex::ToString() const
{
    return strprintf("CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)",
                     pprev, nHeight,
                     hashMerkleRoot.ToString().substr(0,10).c_str(),
                     GetBlockHash().ToString().c_str());               
}
=======
>>>>>>> origin/0.11.2-wrapper



Update to head   check ???



<<<<<<< HEAD
        vRecv >> checkpoint;  //æ¶å°çæ£æ¥ç¹
        LogPrintf("Receive checkpoint,hashCheckpoint=%s\n.",checkpoint.hashCheckpoint.ToString().c_str());
=======
        vRecv >> checkpoint;  //ž³ÖµÁËhashCheckpoint
>>>>>>> origin/0.11.2-wrapper


updated to head  check ???




<<<<<<< HEAD
        		LogPrintf("checkpoint.ProcessSyncCheckpoint(pfrom)=true, hashCheckpoint=%s\n.",checkpoint.hashCheckpoint.ToString().c_str());
=======
        		LogPrintf("checkpoint.ProcessSyncCheckpoint(pfrom)=true, hashCheckpoint=%s\n",checkpoint.hashCheckpoint.ToString().c_str());
>>>>>>> origin/0.11.2-wrapper


updated to head  check ????




<<<<<<< HEAD
            
            LogPrintf("checkpoint.ProcessSyncCheckpoint  Relay=OK \n.");
=======
            LogPrintf("checkpoint.ProcessSyncCheckpoint  Relay=OK \n");
>>>>>>> origin/0.11.2-wrapper



updated to head check ???





<<<<<<< HEAD
	
	/* Message start detector */
        
        
        
	 if ((memcmp(msg.hdr.pchMessageStart, Params().MessageStart(), MESSAGE_START_SIZE) != 0) && (memcmp(msg.hdr.pchMessageStart, Params().MessageStartNew(), MESSAGE_START_SIZE) != 0)) {

	   	LogPrintf("\n\nPROCESSMESSAGE: INVALID MESSAGESTART\n\n");
		fOk = false;
		break;
	   }
	  
=======
        CDataStream::iterator pstart;
        int nHeaderSize;
        bool fMagic;
        
        /* Message start detector */
        unsigned char pchMessageStart[4]    = { 0xfb, 0xc0, 0xb6, 0xdb };
        unsigned char pchMessageStartNew[4] = { 0xfe, 0x46, 0x54, 0x43 };
        //testnet
        if(chainParams.NetworkIDString()=="test") 
        {
		        pchMessageStart[0] = 0xda;
		        pchMessageStartNew[0] = 0xaa;
		        pchMessageStart[1] = 0xaf;
		        pchMessageStartNew[1] = 0xbb;
		        pchMessageStart[2] = 0xa5;
		        pchMessageStartNew[2] = 0xcc;
		        pchMessageStart[3] = 0xba;
		        pchMessageStartNew[3] = 0xdd;
      	}
        
        LogPrintf("PROCESSMESSAGE,pfrom->nVersion=%d,vRecvMsg_HexStr=%s \n",pfrom->nVersion,HexStr(vRecvMsg).c_str());
        
        if(pfrom->nVersion) {
			        if(pfrom->nVersion >= NEW_MAGIC_VERSION) {
			        		fMagic = true;
			        		pstart = search(vRecvMsg.begin(), vRecvMsg.end(), BEGIN(pchMessageStartNew), END(pchMessageStartNew));
			        }
			        else{
			        		fMagic = false;
			        		pstart = search(vRecvMsg.begin(), vRecvMsg.end(), BEGIN(pchMessageStart), END(pchMessageStart));
			        }
        }
        else
        {
        		fMagic = false;
        		pstart = search(vRecvMsg.begin(), vRecvMsg.end(), BEGIN(pchMessageStart), END(pchMessageStart));
        		if(vRecvMsg.end() == pstart) {
                /* Must be the new magic number */
                pstart = search(vRecvMsg.begin(), vRecvMsg.end(), BEGIN(pchMessageStartNew), END(pchMessageStartNew));
                fMagic = true;
            }
        }
        //Message header size=24
        nHeaderSize = vRecvMsg.GetSerializeSize(CMessageHeader(Params().MessageStart(),fMagic));	
        LogPrintf("PROCESSMESSAGE.1 :fMagic=%d,vRecvMsg=%s,nHeaderSize=%d,pstart_to_end=%d,pstart_to_star=%d,vRecv_size=%d \n",fMagic,vRecvMsg.str(), nHeaderSize,vRecvMsg.end() - pstart,pstart - vRecvMsg.begin(),(int)vRecvMsg.size() );			
				
        if (vRecvMsg.end() - pstart < nHeaderSize)
        {
            if ((int)vRecvMsg.size() > nHeaderSize)
            {
                LogPrintf("\n\nPROCESSMESSAGE MESSAGESTART NOT FOUND\n\n");
                vRecvMsg.erase(vRecvMsg.begin(), vRecvMsg.end() - nHeaderSize);
            }
            vector<unsigned char> vRecvMsgOut(vRecvMsg.begin(), vRecvMsg.begin() + nHeaderSize);
            LogPrintf("PROCESSMESSAGE.1.10 this message break,pfrom->nVersion=%d,vRecvMsg_HexStr=%s \n",pfrom->nVersion,HexStr(vRecvMsgOut).c_str());
            break;
        }
        if (pstart - vRecvMsg.begin() > 0)
            LogPrintf("\n\nPROCESSMESSAGE SKIPPED %d BYTES\n\n", pstart - vRecvMsg.begin());
        vRecvMsg.erase(vRecvMsg.begin(), pstart);
>>>>>>> origin/0.11.2-wrapper



message start leave 0.11 check ????




Looks like a fix


<<<<<<< HEAD

	
        /* Don't accept blocks with bogus nVersion numbers after this point */
        if (nHeight >= nForkFour)  {
            if ((block.nVersion !=2)&&(block.nVersion !=4)) 
            {
            		LogPrintf("AcceptBlockHeader,incorrect block version=%d \n",block.nVersion);
                return(state.DoS(100, error("AcceptBlock() : incorrect block version")));
            }
        }
        
        // Check proof of work
        unsigned int uiBits=GetNextWorkRequired(pindexPrev, &block);
        if (block.nBits !=uiBits )
        {
        		LogPrintf("AcceptBlockHeader,GetNextWorkRequired, uiBits=%d ,block.nBits=%d \n",uiBits,block.nBits);
            return state.DoS(100, error("AcceptBlock(),Check proof of work : incorrect proof of work"),
                             REJECT_INVALID, "bad-diffbits");
        }
=======
    int nHeight = pindexPrev->nHeight+1;
    const Consensus::Params& consensusParams = chainParams.GetConsensus(nHeight);

    // Check proof of work
    if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))
    {
    		LogPrintf("ContextualCheckBlockHeader,nHeight=%d,block.nBits=%d,GetNextWorkRequired=%d\n",nHeight,block.nBits,GetNextWorkRequired(pindexPrev, &block, consensusParams));
        return state.DoS(100, error("%s: incorrect proof of work", __func__),
                         REJECT_INVALID, "bad-diffbits");
    }
>>>>>>> origin/0.11.2-wrapper



Updated to head  check ?????







Removing src/leveldb/port/README
Removing src/leveldb/README
Removing src/leveldb/NEWS
Removing src/leveldb/LICENSE
Removing src/leveldb/AUTHORS
Auto-merging src/key.cpp

CONFLICT (content): Merge conflict in src/key.cpp

-copyright



Removing src/json/json_spirit_writer.cpp
Removing src/json/json_spirit_value.cpp
Removing src/json/json_spirit_reader.cpp
Removing src/json/LICENSE.txt
Auto-merging src/init.cpp

CONFLICT (content): Merge conflict in src/init.cpp



<<<<<<< HEAD
                uiInterface.InitMessage(_("Checking ACP ..."));
                if (!CheckCheckpointPubKey()) {
                    strLoadError = _("Checking ACP pubkey failed");
                    break;
                }
            } catch(std::exception &e) {
=======
                
                // Check if the ACP public key has changed in this code version
		// and reset the ACP root to the last hardcoded checkpoint
		uiInterface.InitMessage(_("Checking ACP ..."));
		if (!CheckCheckpointPubKey()) {
		    strLoadError = _("Checking ACP pubkey failed");
		    break;
	}
            } catch (const std::exception& e) {
>>>>>>> origin/0.11.2-wrapper




Update to head check ????









Removing src/feathercoind.cpp
Removing src/feathercoin-cli.cpp
Removing src/feathercoin-cli-res.rc
Removing src/core.h
Removing src/core.cpp
Auto-merging src/coins.cpp

CONFLICT (content): Merge conflict in src/coins.cpp




        const CCoins &coins = GetCoins(txin.prevout.hash);
        if (!coins.IsAvailable(txin.prevout.n)) continue;
        if (coins.nHeight <= nHeight) {
            dResult += (double)(coins.vout[txin.prevout.n].nValue) * (nHeight-coins.nHeight);
=======
        const CCoins* coins = AccessCoins(txin.prevout.hash);
        assert(coins);
        if (!coins->IsAvailable(txin.prevout.n)) continue;
        if (coins->nHeight < nHeight) {
            dResult += coins->vout[txin.prevout.n].nValue * (nHeight-coins->nHeight);
>>>>>>> origin/0.11.2-wrapper



update to head coins check ????







Auto-merging src/clientversion.h

CONFLICT (content): Merge conflict in src/clientversion.h


Update to Head auto VERSIONING 

<<<<<<< HEAD
// These need to be macros, as version.cpp's and bitcoin-qt.rc's voodoo requires it
#define CLIENT_VERSION_MAJOR       0
#define CLIENT_VERSION_MINOR       9
#define CLIENT_VERSION_REVISION    6
#define CLIENT_VERSION_BUILD       1
=======
/**
 * client versioning and copyright year
 */

//! These need to be macros, as clientversion.cpp's and bitcoin*-res.rc's voodoo requires it
#define CLIENT_VERSION_MAJOR 0
#define CLIENT_VERSION_MINOR 11
#define CLIENT_VERSION_REVISION 2
#define CLIENT_VERSION_BUILD 6
>>>>>>> origin/0.11.2-wrapper




Auto-merging src/checkpointsync.h
Auto-merging src/checkpointsync.cpp

CONFLICT (content): Merge conflict in src/checkpointsync.cpp





Done ???  check  master key is correct





Auto-merging src/checkpoints.cpp



CONFLICT (content): Merge conflict in src/checkpoints.cpp


    struct CCheckpointData {
        const MapCheckpoints *mapCheckpoints;
        int64_t nTimeLastCheckpoint;
        int64_t nTransactionsLastCheckpoint;
        double fTransactionsPerDay;
    };

    bool fEnabled = true;

    // What makes a good checkpoint block?
    // + Is surrounded by blocks with reasonable timestamps
    //   (no blocks before with a timestamp after, none after with
    //    timestamp before)
    // + Contains no strange transactions
    static MapCheckpoints mapCheckpoints =
            boost::assign::map_list_of
            (     1, uint256("0xfdbe99b90c90bae7505796461471d89ae8388ab953997aa06a355bbda8d915cb"))
            (     22267, uint256("0x23dc7d871fc2a9b994112e978019f6370bab0b8979f557afe77a7ab620224b70"))
            (     22847, uint256("0x1450b80c150fee1e657ee8309819276342c021fab5e6a20ccf5407f5e2218d0f"))
            (     23453, uint256("0x7c25d3f9671e1d9400c9a1be2ff68e68db561ab85ae6b7020062d8d26da81e4c"))
            (     28230, uint256("0xd3feb71f92c63c682f994d7c615adc425226c669a83d46012b32fc8d518b08bb"))
            (     31846, uint256("0xba7d5c0e6d46f6448253290ce037e13975c13ca9c375ae854b6b2f85044fc0f9"))
            (     33918, uint256("0x023cf4acfd8bf0114090a7ce048e79ac28152de78bb41f1277742904494e6c49"))
			(     34000, uint256("0x082f5d9023af3f068733ab68cf81b741f58e3c75ae28d2a9bd07f30b74c38356"))
			(     41300, uint256("0x8c4e02f6c0d20e856fd7e952a147fee30ce145ca6932a284f354924362d2b408"))
			(   1114311, uint256("0x93515f222f16a9ff3db6594e5ee7c12924cff9ba05b01dbe551d0a9e65dd141f"))
			(   1593400, uint256("0xe97230c788e7240eb325576810fee62f5162905f63a832f15928b88ac6a938c6"))
                        (   1776411, uint256("0x4f6de194bd2f4580e2ac9337289c7cca348d3f35c9079af2760b288315b82feb"))
                 ;
    static const CCheckpointData data = {
        &mapCheckpoints,
        1498636263, // * UNIX timestamp of last checkpoint block
        3660284,    // * total number of transactions between genesis and last checkpoint
                    //   (the tx=... number in the SetBestChain or Updatetip debug.log lines)
        1500.0     // * estimated number of transactions per day after checkpoint
    };

    static MapCheckpoints mapCheckpointsTestnet =
        boost::assign::map_list_of
        ( 546, uint256("000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70"))
        ;
    static const CCheckpointData dataTestnet = {
        &mapCheckpointsTestnet,
        1338180505,
        16341,
        300
    };

    static MapCheckpoints mapCheckpointsRegtest =
        boost::assign::map_list_of
        ( 0, uint256("0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206"))
        ;
    static const CCheckpointData dataRegtest = {
        &mapCheckpointsRegtest,
        0,
        0,
        0
    };

    const CCheckpointData &Checkpoints() {
        if (Params().NetworkID() == CChainParams::TESTNET)
            return dataTestnet;
        else if (Params().NetworkID() == CChainParams::MAIN)
            return data;
        else
            return dataRegtest;
    }

    bool CheckBlock(int nHeight, const uint256& hash)
=======
    bool CheckBlock(const CCheckpointData& data, int nHeight, const uint256& hash)
>>>>>>> origin/0.11.2-wrapper


Moved checkpoints to head




Auto-merging src/chainparams.h

CONFLICT (content): Merge conflict in src/chainparams.h



Done ?????






Auto-merging src/chainparams.cpp

CONFLICT (content): Merge conflict in src/chainparams.cpp


<<<<<<< HEAD

        pchMessageStartNew[0] = 0xfe;
        pchMessageStartNew[1] = 0x46;
        pchMessageStartNew[2] = 0x54;
        pchMessageStartNew[3] = 0x43;
        //how to do
        //vAlertPubKey = ParseHex("04d4da7a5dae4db797d9b0644d57a5cd50e05a70f36091cd62e2fc41c98ded06340be5a43a35e185690cd9cde5d72da8f6d065b499b06f51dcfba14aad859f443a");
        vAlertPubKey = ParseHex("043c19a29fe8f763369aea68107e82854af7b072fc7d2d2adb87d2a3b40b51ab0d0e77805096e255a87388b175fd4a49d93d9b6c878004975e41222a3b85086eef");
        nDefaultPort = 9336;
        nRPCPort = 9337;
        bnProofOfWorkLimit = CBigNum(~uint256(0) >> 20);
        nSubsidyHalvingInterval = 2100000; //half every 2100000 blocks

        // Build the genesis block. Note that the output of the genesis coinbase cannot
        // be spent as it did not originally exist in the database.
        //
        // Genesis Block:
        // CBlock(hash=12a765e31ffd4059bada, PoW=0000050c34a64b415b6b, ver=1, hashPrevBlock=00000000000000000000, hashMerkleRoot=97ddfbbae6, nTime=1317972665, nBits=1e0ffff0, nNonce=2084524493, vtx=1)
        //   CTransaction(hash=97ddfbbae6, ver=1, vin.size=1, vout.size=1, nLockTime=0)
        //     CTxIn(COutPoint(0000000000, -1), coinbase 04ffff001d0104404e592054696d65732030352f4f63742f32303131205374657665204a6f62732c204170706c65e280997320566973696f6e6172792c2044696573206174203536)
        //     CTxOut(nValue=50.00000000, scriptPubKey=040184710fa689ad5023690c80f3a4)
        //   vMerkleTree: 97ddfbbae6
=======
        pchMessageStartNew[3] = 0x43;

        vAlertPubKey = ParseHex("043c19a29fe8f763369aea68107e82854af7b072fc7d2d2adb87d2a3b40b51ab0d0e77805096e255a87388b175fd4a49d93d9b6c878004975e41222a3b85086eef");
        nDefaultPort = 9336;
        nMinerThreads = 0;
        nMaxTipAge = 24 * 60 * 60;
        nPruneAfterHeight = 100000;

        /**
         * Build the genesis block. Note that the output of its generation
         * transaction cannot be spent since it did not originally exist in the
         * database.
         *
         * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)
         *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)
         *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)
         *     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)
         *   vMerkleTree: 4a5e1e
         */
>>>>>>> origin/0.11.2-wrapper



Updated to Head




<<<<<<< HEAD
        vSeeds.push_back(CDNSSeedData("explorer2.feathercoin.com", "explorer2.feathercoin.com"));
        vSeeds.push_back(CDNSSeedData("alltheco.in", "dnsseed.alltheco.in"));
        vSeeds.push_back(CDNSSeedData("ftc-c.com", "block.ftc-c.com"));


        //how to do feathercoin ?
        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,14); // FeatherCoin addresses start with F
        base58Prefixes[SCRIPT_ADDRESS_OLD] = std::vector<unsigned char>(1,5);
      //  base58Prefixes[SCRIPT_ADDRESS] = list_of(96);
        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);
        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,142);// 14+128
        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xBC)(0x26).convert_to_container<std::vector<unsigned char> >();
        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xDA)(0xEE).convert_to_container<std::vector<unsigned char> >();
        //base58Prefixes[EXT_SCRIPT_ADDRESS] = list_of(96);
=======
        vSeeds.push_back(CDNSSeedData("ftc-c.com", "dnsseed.ftc-c.com"));
        vSeeds.push_back(CDNSSeedData("block.ftc-c.com", "block.ftc-c.com"));
        vSeeds.push_back(CDNSSeedData("pool.ftc-c.com", "pool.ftc-c.com"));
        vSeeds.push_back(CDNSSeedData("testnet.ftc-c.com", "testnet.ftc-c.com"));
>>>>>>> origin/0.11.2-wrapper



Updated to head





Auto-merging src/bitcoin-tx-res.rc

CONFLICT (rename/delete): src/bitcoin-config.h.in deleted in origin/0.11.2-wrapper and renamed in HEAD. Version HEAD of src/bitcoin-config.h.in left in tree.


Leave in for the moment  check ????? and delete later.


Auto-merging src/base58.cpp

CONFLICT (content): Merge conflict in src/base58.cpp


-copyright




CONFLICT (modify/delete): src/base40.h deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of src/base40.h left in tree.


Left in for moment  check ?????


Leave in for the moment  check ????? and delete later.

Removing src/auxpow.h
Removing src/auxpow.cpp
Auto-merging src/alert.h

CONFLICT (content): Merge conflict in src/alert.h


done ????? check



Auto-merging src/alert.cpp

CONFLICT (content): Merge conflict in src/alert.cpp


done ?????



Removing src/Makefile.include
Removing share/ui.rc
Removing share/qt/protobuf.pri

CONFLICT (modify/delete): share/qt/make_spinner.py deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of share/qt/make_spinner.py left in tree.
CONFLICT (modify/delete): share/qt/img/reload.xcf deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of share/qt/img/reload.xcf left in tree.
CONFLICT (modify/delete): share/qt/img/reload.png deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of share/qt/img/reload.png left in tree.


Leave in delete update later check ????


Removing share/qt/extract_strings_qt.py

Auto-merging share/qt/Info.plist.in

CONFLICT (content): Merge conflict in share/qt/Info.plist.in



<<<<<<< HEAD
  <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@, Copyright © 2009-@COPYRIGHT_YEAR@ The Feathercoin Core developers</string>
=======
  <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_REVISION@, Copyright © 2009-@COPYRIGHT_YEAR@ The Feathercoin Core developers</string>
>>>>>>> origin/0.11.2-wrapper

  <key>CFBundleShortVersionString</key>
  <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_REVISION@</string>

  <key>CFBundleVersion</key>
  <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_REVISION@</string>

  <key>CFBundleSignature</key>
  <string>????</string>

  <key>CFBundleExecutable</key>
  <string>Feathercoin-Qt</string>
<<<<<<< HEAD
=======

<<<<<<< HEAD
=======
  
  <key>CFBundleName</key>
  <string>Feathercoin-Qt</string>

  <key>LSHasLocalizedDisplayName</key>
  <true/>
>>>>>>> origin/0.11.2-wrapper




Moved to head check ???? and removed "core"






Removing share/pixmaps/send20mask.bmp
Removing share/pixmaps/send20.bmp
Removing share/pixmaps/send16masknoshadow.bmp
Removing share/pixmaps/send16mask.bmp
Removing share/pixmaps/send16.bmp

CONFLICT (modify/delete): share/pixmaps/nsis-wizard.bmp deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of share/pixmaps/nsis-wizard.bmp left in tree.
CONFLICT (modify/delete): share/pixmaps/nsis-header.bmp deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of share/pixmaps/nsis-header.bmp left in tree.


Leave in for moment delete later check ?????









Removing share/pixmaps/favicon.ico
Removing share/pixmaps/check.ico
Removing share/pixmaps/bitcoin64.xpm
Removing share/pixmaps/bitcoin64.png
Removing share/pixmaps/bitcoin32.xpm
Removing share/pixmaps/bitcoin32.png
Removing share/pixmaps/bitcoin256.xpm
Removing share/pixmaps/bitcoin256.png
Removing share/pixmaps/bitcoin16.xpm
Removing share/pixmaps/bitcoin16.png
Removing share/pixmaps/bitcoin128.xpm
Removing share/pixmaps/bitcoin128.png


CONFLICT (modify/delete): share/pixmaps/bitcoin.ico deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of share/pixmaps/bitcoin.ico left in tree.


Leave in for moment delete later check ?????



Removing share/pixmaps/bitcoin-bc.ico
Removing share/pixmaps/addressbook20mask.bmp
Removing share/pixmaps/addressbook20.bmp
Removing share/pixmaps/addressbook16mask.bmp
Removing share/pixmaps/addressbook16.bmp
Removing share/certs/PrivateKeyNotes.md
Removing share/certs/BitcoinFoundation_Comodo_Cert.pem
Removing share/certs/BitcoinFoundation_Apple_Cert.pem
Removing qa/rpc-tests/walletbackup.sh
Removing qa/rpc-tests/wallet.sh
Removing qa/rpc-tests/util.sh
Removing qa/rpc-tests/util.py
Removing qa/rpc-tests/txnmall.sh
Auto-merging qa/rpc-tests/test_framework/authproxy.py
Removing qa/rpc-tests/skeleton.py
Removing qa/rpc-tests/send.sh
Removing qa/rpc-tests/python-bitcoinrpc/setup.py
Removing qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/__init__.py
Removing qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/.gitignore
Removing qa/rpc-tests/conflictedbalance.sh
Removing qa/pull-tester/pull-tester.sh
Removing qa/pull-tester/pull-tester.py
Removing qa/pull-tester/build-tests.sh.in
Removing pkg.m4
Removing doc_install/release-notes-0.9.0.md
Removing doc/gitian-building/select_startup_disk.png
Removing doc/gitian-building/port_forwarding_rules.png
Removing doc/gitian-building/network_settings.png
Removing doc/gitian-building/debian_install_9_user_password.png
Removing doc/gitian-building/debian_install_8_set_up_username.png
Removing doc/gitian-building/debian_install_7_set_up_user_fullname.png
Removing doc/gitian-building/debian_install_6a_set_up_root_password.png
Removing doc/gitian-building/debian_install_6_domain_name.png
Removing doc/gitian-building/debian_install_5_configure_the_network.png
Removing doc/gitian-building/debian_install_4_configure_keyboard.png
Removing doc/gitian-building/debian_install_3_select_location.png
Removing doc/gitian-building/debian_install_2_select_a_language.png
Removing doc/gitian-building/debian_install_21_finish_installation.png
Removing doc/gitian-building/debian_install_20_install_grub.png
Removing doc/gitian-building/debian_install_1_boot_menu.png
Removing doc/gitian-building/debian_install_19_software_selection.png
Removing doc/gitian-building/debian_install_18_proxy_settings.png
Removing doc/gitian-building/debian_install_17_choose_a_mirror2.png
Removing doc/gitian-building/debian_install_16_choose_a_mirror.png
Removing doc/gitian-building/debian_install_15_write_changes.png
Removing doc/gitian-building/debian_install_14_finish.png
Removing doc/gitian-building/debian_install_13_partition_scheme.png
Removing doc/gitian-building/debian_install_12_choose_disk.png
Removing doc/gitian-building/debian_install_11_partition_disks.png
Removing doc/gitian-building/debian_install_10_configure_clock.png
Removing doc/gitian-building/create_vm_storage_physical_hard_drive.png
Removing doc/gitian-building/create_vm_page1.png
Removing doc/gitian-building/create_vm_memsize.png
Removing doc/gitian-building/create_vm_hard_drive_file_type.png
Removing doc/gitian-building/create_vm_hard_drive.png
Removing doc/gitian-building/create_vm_file_location_size.png
Removing doc/coding.md
Removing doc/build-msw.md
Auto-merging doc/README.md



CONFLICT (content): Merge conflict in doc/README.md


Updated to Head Fixed versions.

### Build the Feathercoin binaries  
    
    cd Feathercoin  
    make clean  
     ./autogen.sh
     ./configure --with-gui=qt5 --enable-tests=no  --with-incompatible-bdb --enable-upnp-default --with-qrcode=yes   --enable-shared --disable-hardening LDFLAGS="-L${BDB_PREFIX}/lib/" CPPFLAGS="-I${BDB_PREFIX}/include/" CXXFLAGS="$CXXFLAGS -fPIC -m64 -std=c++11"
    time make 
    make install
    
### Creating a Launcher




Removing doc/Doxyfile
Removing contrib/verifysfbinaries/verify.sh
Removing contrib/verifysfbinaries/README.md
Removing contrib/tidy_datadir.sh
Removing contrib/testgen/gen_base58_test_vectors.py
Removing contrib/testgen/base58.py
Removing contrib/testgen/README.md
Removing contrib/test-patches/temp-revert-2.patch
Removing contrib/test-patches/README.md
Removing contrib/spendfrom/spendfrom.py
Removing contrib/spendfrom/setup.py
Removing contrib/spendfrom/README.md
Removing contrib/seeds/makeseeds.py
Removing contrib/seeds/README.md
Removing contrib/qt_translations.py
Removing contrib/qos/tc.sh
Removing contrib/qos/README.md
Removing contrib/pyminer/pyminer.py
Removing contrib/pyminer/example-config.cfg
Removing contrib/pyminer/README.md

CONFLICT (modify/delete): contrib/macdeploy/macdeployqtplus deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of contrib/macdeploy/macdeployqtplus left in tree.

Leave in for moment check ????



Auto-merging contrib/macdeploy/fancy.plist

CONFLICT (modify/delete): contrib/macdeploy/background.psd deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of contrib/macdeploy/background.psd left in tree.
CONFLICT (modify/delete): contrib/macdeploy/background.png deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of contrib/macdeploy/background.png left in tree.
CONFLICT (modify/delete): contrib/macdeploy/README.md deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of contrib/macdeploy/README.md left in tree.

Leave in for moment check ????



Removing contrib/macdeploy/LICENSE
Removing contrib/macdeploy/DS_Store
Removing contrib/linearize/linearize.py
Removing contrib/linearize/example-linearize.cfg
Removing contrib/linearize/README.md
Removing contrib/gitian-downloader/wtogami-key.pgp
Removing contrib/gitian-downloader/win32-download-config
Removing contrib/gitian-downloader/tcatm-key.pgp
Removing contrib/gitian-downloader/sipa-key.pgp
Removing contrib/gitian-downloader/michagogo-key.pgp
Removing contrib/gitian-downloader/luke-jr-key.pgp
Removing contrib/gitian-downloader/linux-download-config
Removing contrib/gitian-downloader/laanwj-key.pgp
Removing contrib/gitian-downloader/gavinandresen-key.pgp
Removing contrib/gitian-downloader/devrandom-key.pgp
Removing contrib/gitian-downloader/bluematt-key.pgp
Removing contrib/gitian-downloader/aschildbach-key.pgp
Removing contrib/gitian-descriptors/qt-win.yml
Removing contrib/gitian-descriptors/protobuf-win.yml
Removing contrib/gitian-descriptors/gitian-win.yml
Removing contrib/gitian-descriptors/gitian-linux.yml
Removing contrib/gitian-descriptors/deps-win.yml
Removing contrib/gitian-descriptors/deps-linux.yml
Removing contrib/gitian-descriptors/boost-win.yml
Removing contrib/gitian-descriptors/boost-linux.yml
Removing contrib/gitian-descriptors/README.md
Removing contrib/devtools/github-merge.sh
Removing contrib/devtools/fix-copyright-headers.py
Removing contrib/devtools/README.md
Removing contrib/debian/watch
Removing contrib/debian/source/format
Removing contrib/debian/rules
Removing contrib/debian/patches/series
Removing contrib/debian/patches/README

CONFLICT (rename/delete): contrib/debian/manpages/feathercoind.1 deleted in origin/0.11.2-wrapper and renamed in HEAD. Version HEAD of contrib/debian/manpages/feathercoind.1 left in tree.
CONFLICT (rename/delete): contrib/debian/manpages/feathercoin.conf.5 deleted in origin/0.11.2-wrapper and renamed in HEAD. Version HEAD of contrib/debian/manpages/feathercoin.conf.5 left in tree.
CONFLICT (rename/delete): contrib/debian/manpages/feathercoin-qt.1 deleted in origin/0.11.2-wrapper and renamed in HEAD. Version HEAD of contrib/debian/manpages/feathercoin-qt.1 left in tree.


Leave in for moment check ????


Removing contrib/debian/gbp.conf
Removing contrib/debian/examples/bitcoin.conf
Removing contrib/debian/copyright
Removing contrib/debian/control
Removing contrib/debian/compat
Removing contrib/debian/changelog
Removing contrib/debian/bitcoind.manpages
Removing contrib/debian/bitcoind.lintian-overrides
Removing contrib/debian/bitcoind.install
Removing contrib/debian/bitcoind.examples
Removing contrib/debian/bitcoind.bash-completion
Removing contrib/debian/bitcoin-qt.protocol
Removing contrib/debian/bitcoin-qt.lintian-overrides
Removing contrib/debian/bitcoin-qt.install
Removing contrib/debian/bitcoin-qt.desktop
Removing contrib/debian/README.md
Removing contrib/bitrpc/bitrpc.py
Removing contrib/bitrpc/README.md
Removing contrib/bitcoind.bash-completion
Removing contrib/README.md
Auto-merging configure.ac





CONFLICT (content): Merge conflict in configure.ac






<<<<<<< HEAD
define(_CLIENT_VERSION_MINOR, 9)
define(_CLIENT_VERSION_REVISION, 6)
define(_CLIENT_VERSION_BUILD, 2)
define(_CLIENT_VERSION_IS_RELEASE, false)
define(_COPYRIGHT_YEAR, 2017)
AC_INIT([Feathercoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[https://github.com/FeatherCoin/Feathercoin/issues],[feathercoin])
AC_CONFIG_AUX_DIR([src/build-aux])
AC_CONFIG_MACRO_DIR([src/m4])
=======
define(_CLIENT_VERSION_MINOR, 11)
define(_CLIENT_VERSION_REVISION, 2)
define(_CLIENT_VERSION_BUILD, 6)
define(_CLIENT_VERSION_IS_RELEASE, false)
define(_COPYRIGHT_YEAR, 2017)
define(_USE_ZXING,1)
AC_INIT([Feathercoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[https://github.com/feathercoin2/feathercoin2/issues],[feathercoin])
AC_CONFIG_SRCDIR([src/main.cpp])
AC_CONFIG_HEADERS([src/config/bitcoin-config.h])
AC_CONFIG_AUX_DIR([build-aux])
AC_CONFIG_MACRO_DIR([build-aux/m4])

>>>>>>> origin/0.11.2-wrapper


Info site updated to gitgub  

Update to Head but use version 0.11 version numbers  check ???


zxing and ac_configs copid back in.



<<<<<<< HEAD
    # AX_CHECK_LINK_FLAG([[-static]],[LDFLAGS="$LDFLAGS -static"])
     AX_CHECK_LINK_FLAG([[-static-libgcc]],[LDFLAGS="$LDFLAGS -static-libgcc"])
     AX_CHECK_LINK_FLAG([[-static-libstdc++]],[LDFLAGS="$LDFLAGS -static-libstdc++"])
	
    # the below fixes a bug in windows static builds. 
     if test x$Q_OS_WIN; then
	AX_CHECK_LINK_FLAG([[-static]],[LDFLAGS="$LDFLAGS -static"; LIBTOOL_LDFLAGS="$LIBTOOL_LDFLAGS -static"])
	AC_MSG_NOTICE([NOTICE: You're building for Windows])
     fi
     
=======
     # -static is interpreted by libtool, where it has a different meaning.
     # In libtool-speak, it's -all-static.
     AX_CHECK_LINK_FLAG([[-static]],[LIBTOOL_APP_LDFLAGS="$LIBTOOL_APP_LDFLAGS -all-static"])

>>>>>>> origin/0.11.2-wrapper


Updated to Head but check ????  comment out 0.11 so can be tested



<<<<<<< HEAD
     extern "C" long unsigned int __fdelt_warn(long unsigned int);]], [[]])],[ fdelt_type="long unsigned int"],[ fdelt_type="long int"])
=======
     extern "C" long unsigned int __fdelt_warn(long unsigned int);]],[[]])],
    [ fdelt_type="long unsigned int"],
    [ fdelt_type="long int"])
>>>>>>> origin/0.11.2-wrapper


Move to head and comment old one in case check ????





<<<<<<< HEAD
AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]], [[ int f = MSG_NOSIGNAL; ]])],[ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_MSG_NOSIGNAL, 1,[Define this symbol if you have MSG_NOSIGNAL]) ],[ AC_MSG_RESULT(no)
])
=======
AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],
 [[ int f = MSG_NOSIGNAL; ]])],
 [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_MSG_NOSIGNAL, 1,[Define this symbol if you have MSG_NOSIGNAL]) ],
 [ AC_MSG_RESULT(no)]
)
>>>>>>> origin/0.11.2-wrapper



<<<<<<< HEAD
  ]], [[
=======
  ]],[[
>>>>>>> origin/0.11.2-wrapper
  #if BOOST_VERSION >= 105000 && (!defined(BOOST_HAS_NANOSLEEP) || BOOST_VERSION >= 105200)
      boost::this_thread::sleep_for(boost::chrono::milliseconds(0));
  #else
   choke me
  #endif
<<<<<<< HEAD
  ]])],[boost_sleep=yes; BOOST_LIBS="$BOOST_LIBS $BOOST_CHRONO_LIB";
     AC_DEFINE(HAVE_WORKING_BOOST_SLEEP_FOR, 1, [Define this symbol if boost sleep_for works])],[boost_sleep=no])
=======
  ]])],
  [boost_sleep=yes;
     AC_DEFINE(HAVE_WORKING_BOOST_SLEEP_FOR, 1, [Define this symbol if boost sleep_for works])],
  [boost_sleep=no])
>>>>>>> origin/0.11.2-wrapper
LIBS="$TEMP_LIBS"
CPPFLAGS="$TEMP_CPPFLAGS"

if test x$boost_sleep != xyes; then
TEMP_LIBS="$LIBS"
LIBS="$BOOST_LIBS $LIBS"
TEMP_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
AC_LINK_IFELSE([AC_LANG_PROGRAM([[
  #include <boost/version.hpp>
  #include <boost/thread.hpp>
  #include <boost/date_time/posix_time/posix_time_types.hpp>
<<<<<<< HEAD
  ]], [[
=======
  ]],[[
>>>>>>> origin/0.11.2-wrapper
  #if BOOST_VERSION <= 105600
      boost::this_thread::sleep(boost::posix_time::milliseconds(0));
  #else
   choke me
  #endif
<<<<<<< HEAD
  ]])],[boost_sleep=yes; AC_DEFINE(HAVE_WORKING_BOOST_SLEEP, 1, [Define this symbol if boost sleep works])],[boost_sleep=no])
=======
  ]])],
  [boost_sleep=yes; AC_DEFINE(HAVE_WORKING_BOOST_SLEEP, 1, [Define this symbol if boost sleep works])],
  [boost_sleep=no])
>>>>>>> origin/0.11.2-wrapper
LIBS="$TEMP_LIBS"




Moved to head check ?????




<<<<<<< HEAD
      #  PKG_CHECK_MODULES([ZXING], [zxing],, [AC_MSG_ERROR(libzxing  not found.)])
        BITCOIN_QT_CHECK([AC_CHECK_LIB([zxing], [main],, [have_zxing=no])])
      #  PKG_CHECK_MODULES([QRENCODE], [libqrencode],, [AC_MSG_ERROR(libqrencode  not found.)])
        BITCOIN_QT_CHECK([AC_CHECK_LIB([qrencode], [main],, [have_qr=no])])
=======
        BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])
>>>>>>> origin/0.11.2-wrapper


Moved to head check commented out in case ?????



<<<<<<< HEAD
    BITCOIN_QT_CHECK([AC_CHECK_LIB([zxing], [main],, BITCOIN_QT_FAIL(libzxing not found))])
    BITCOIN_QT_CHECK([AC_CHECK_HEADER([zxing.h],, have_qzxing=no)])
    BITCOIN_QT_CHECK([AC_CHECK_HEADER([qrencode.h],, have_qr=no)])
=======
    BITCOIN_QT_CHECK([AC_CHECK_LIB([qrencode], [main],[QR_LIBS=-lqrencode], [have_qrencode=no])])
    BITCOIN_QT_CHECK([AC_CHECK_HEADER([qrencode.h],, have_qrencode=no)])
>>>>>>> origin/0.11.2-wrapper


moved to head commented in case check ????



<<<<<<< HEAD
  if test x$have_zxing = xno; then
    if test x$use_qr == xyes; then
=======
  if test x$have_qrencode = xno; then
    if test x$use_qr = xyes; then
>>>>>>> origin/0.11.2-wrapper
     AC_MSG_ERROR("QR support requested but cannot be built. use --without-qrencode")
    fi
    AC_MSG_RESULT(no)
  else
    if test x$use_qr != xno; then
      AC_MSG_RESULT(yes)
<<<<<<< HEAD
      AC_DEFINE([USE_ZXING],[1],[Define if QR support should be compiled in])
      use_zxing=yes
      AC_DEFINE([USE_QRCODE],[0],[Define if QR support should be compiled in])
      use_qr=no
=======
      AC_DEFINE([USE_QRCODE],[1],[Define if QR support should be compiled in])
      use_qr=yes
>>>>>>> origin/0.11.2-wrapper


Moved to head


<<<<<< HEAD
AC_SUBST(LIBTOOL_LDFLAGS)
=======
AC_SUBST(USE_ZXING, _USE_ZXING)

AC_SUBST(RELDFLAGS)
AC_SUBST(LIBTOOL_APP_LDFLAGS)
>>>>>>> origin/0.11.2-wrapper

moved to head

Note   check ???   left (RELDFLAGS) in just in case *****






Auto-merging autogen.sh

CONFLICT (content): Merge conflict in autogen.sh

#!/bin/sh
set -e
<<<<<<< HEAD
echo running autoreconf .....
autoreconf  -if --warnings=all
autoupdate
echo
echo running autoupdate completed .....
=======
srcdir="$(dirname $0)"
cd "$srcdir"
if [ -z ${LIBTOOLIZE} ] && GLIBTOOLIZE="`which glibtoolize 2>/dev/null`"; then
  LIBTOOLIZE="${GLIBTOOLIZE}"
  export LIBTOOLIZE
fi
autoreconf --install --force --warnings=all
>>>>>>> origin/0.11.2-wrapper


integrated both together note install etc

#!/bin/sh
set -e
srcdir="$(dirname $0)"
cd "$srcdir"
if [ -z ${LIBTOOLIZE} ] && GLIBTOOLIZE="`which glibtoolize 2>/dev/null`"; then
  LIBTOOLIZE="${GLIBTOOLIZE}"
  export LIBTOOLIZE
fi
echo running autoreconf .....
// autoreconf  -if --warnings=all
autoreconf --install --force --warnings=all
autoupdate
echo
echo running autoupdate completed .....






Auto-merging aclocal.m4

CONFLICT (add/add): Merge conflict in aclocal.m4


left as 0.11 new build structure



Auto-merging README.md

CONFLICT (content): Merge conflict in README.md
CONFLICT (modify/delete): INSTALL deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of INSTALL left in tree.
CONFLICT (modify/delete): COPYING deleted in origin/0.11.2-wrapper and modified in HEAD. Version HEAD of COPYING left in tree.

left in for moment delete later check ?????



Auto-merging .gitignore

CONFLICT (content): Merge conflict in .gitignore



<<<<<<< HEAD
*.tar.gz
*.exe
*.directory
Makefile*
*.in

#ignore binaries
src/feathercoin
src/feathercoind
src/feathercoin-cli
src/qt/test/test_feathercoin-qt
src/test/test_feathercoin


# ignore files created by autoconf and conf
src/bitcoin-config.h
src/bitcoin-config.h
src/Makefile.in
Makefile.in
Makefile
share/qt/Info.plist
share/setup.nsi
src/Makefile.in
src/bitcoin-config.h
src/qt/Makefile.in
src/qt/test/Makefile.in
src/test/Makefile.in
src/test/Makefile.in
src/test/test_bitcoin
src/stamp-h1

#ignore files created during make
src/qt/*.moc
src/qt/moc_*.cpp
src/qt/forms/ui_*.h
src/qt/Makefile.in
src/qt/test/moc*.cpp
src/qt/test/test_bitcoin-qt
src/qt/test/Makefile.in


autom4te.cache/
config.log
config.status
configure


=======
# ignore compiler generated files
*.o
*.lo
*.so
*.a
*.la
feathercoind
feathercoin-qt
feathercoin-cli
feathercoin-tx
.dirstamp
*/obj/*
moc_*
*moc
src/qt/locale/*.qm

# ignore  files generated by autogen.sh
build-aux/debcomp
build-aux/install-sh
build-aux/ltmain.sh
build-aux/missing
build-aux/test-driver
src/config/bitcoin-config.h.in
modified:   aclocal.m4
build-aux/m4/libtool.m4
src/config/bitcoin-config.h.in
src/secp256k1/aclocal.m4

.directory
.libs
libtool
*.log
Makefile
Makefile.in
*.cache
config/*
config.*
configure
*.cache/
qa/pull-tester/build-tests.sh
qa/pull-tester/run-bitcoind-for-test.sh
qa/pull-tester/tests-config.sh
share/qt/Info.plist
share/setup.nsi
src/.deps/
src/Makefile
src/bitcoin-config.h.in
src/build-aux/
src/compat/.deps/
src/config/bitcoin-config.h
src/config/bitcoin-config.h.in~
src/config/stamp-h1
src/crypto/.deps/
src/policy/.deps/
src/primitives/.deps/
src/qt/.deps/
src/qt/Makefile
src/qt/Makefile.in
src/qt/test/.deps/
src/qt/test/Makefile
src/qt/test/Makefile.in
src/script/.deps/
src/secp256k1/Makefile
src/secp256k1/build-aux/depcomp
src/secp256k1/build-aux/install-sh
src/secp256k1/build-aux/missing
src/secp256k1/build-aux/test-driver
src/secp256k1/libsecp256k1.pc
src/secp256k1/libtool
src/secp256k1/src/.deps/
src/secp256k1/src/libsecp256k1-config.h
src/secp256k1/src/libsecp256k1-config.h.in~
stamp-h1
>>>>>>> origin/0.11.2-wrapper


Commented out head changes for review.  check ??????





Removing .gitattributes
Automatic merge failed; fix conflicts and then commit the result.
